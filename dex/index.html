<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AssetChain DEX - Airtime & Data Marketplace</title>
  <link rel="icon" href="../assets/img/favicon.png" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <script src="https://cdn.jsdelivr.net/npm/sweetalert@2.1.2/dist/sweetalert.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
  <!-- Self-hosted approach: no external Web3Onboard. Use EIP-1193/EIP-6963 detection. -->
  <script>
    // Collect EIP-6963 announced providers
    window.availableInjectedProviders = [];
    window.addEventListener('eip6963:announceProvider', (event) => {
      try {
        const info = event.detail?.info;
        const provider = event.detail?.provider;
        if (!info || !provider) return;
        const exists = window.availableInjectedProviders.some(p => p.info?.rdns === info.rdns);
        if (!exists) window.availableInjectedProviders.push({ info, provider });
      } catch (_) { }
    });
    // Trigger discovery (EIP-6963 uses singular 'requestProvider')
    window.dispatchEvent(new Event('eip6963:requestProvider'));
  </script>
  <style>
    :root {
      --primary: #384fff;
      --primary-dark: #2b65e3;
      --secondary: #00C2FF;
      --accent: #FF3E80;
      --dark: #0F1423;
      --darker: #0A0E1A;
      --light: #F5F7FF;
      --gray: #8A94A6;
      --success: #4CAF50;
      --warning: #FFB547;
      --error: #F44336;
      --card-bg: rgba(0, 0, 0, 0.72);
      --border-radius: 16px;
      --transition: all 0.3s ease;
    }

    /* Light Theme Overrides */
    [data-theme="light"] {
      --dark: #FFFFFF;
      --darker: #F0F2F5;
      --light: #1A1E2E;
      --gray: #5E6C84;
      --card-bg: rgba(255, 255, 255, 0.9);
      --border-color: rgba(0, 0, 0, 0.1);
    }

    [data-theme="light"] body {
      background: linear-gradient(135deg, #F0F2F5 0%, #FFFFFF 100%);
      color: var(--light);
    }

    [data-theme="light"] .card,
    [data-theme="light"] .tips-section,
    [data-theme="light"] .receipt-card,
    [data-theme="light"] .wallet-dropdown {
      background: var(--card-bg);
      border-color: rgba(0, 0, 0, 0.08);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
    }

    [data-theme="light"] input,
    [data-theme="light"] select {
      background: rgba(0, 0, 0, 0.03);
      border-color: rgba(0, 0, 0, 0.1);
      color: var(--light);
    }

    [data-theme="light"] input:focus,
    [data-theme="light"] select:focus {
      background: #FFFFFF;
      border-color: var(--primary);
    }

    [data-theme="light"] .btn-secondary {
      background: rgba(0, 0, 0, 0.05);
      color: var(--light);
    }

    [data-theme="light"] .btn-secondary:hover {
      background: rgba(0, 0, 0, 0.08);
    }

    [data-theme="light"] header {
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      background: rgba(255, 255, 255, 0.8);
    }

    [data-theme="light"] .nav-links a:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    [data-theme="light"] .wallet-info {
      background: rgba(0, 0, 0, 0.03);
      border-color: rgba(0, 0, 0, 0.1);
    }

    #theme-toggle {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.1);
      color: var(--light);
      width: 40px;
      height: 40px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
      margin-left: 10px;
    }

    #theme-toggle:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    [data-theme="light"] #theme-toggle {
      border-color: rgba(0, 0, 0, 0.1);
    }

    [data-theme="light"] #theme-toggle:hover {
      background: rgba(0, 0, 0, 0.05);
    }

    [data-theme="light"] .hamburger {
      border-color: rgba(0, 0, 0, 0.1);
    }

    [data-theme="light"] .hamburger:hover {
      background: rgba(0, 0, 0, 0.05);
      border-color: rgba(0, 0, 0, 0.2);
    }

    [data-theme="light"] .hamburger .bars span {
      background: var(--light);
    }

    [data-theme="light"] .mobile-nav {
      background: #FFFFFF;
      border-left: 1px solid rgba(0, 0, 0, 0.1);
      box-shadow: -5px 0 15px rgba(0, 0, 0, 0.05);
    }

    [data-theme="light"] .mobile-nav a {
      color: var(--light);
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    [data-theme="light"] .mobile-nav a:hover {
      background: rgba(0, 0, 0, 0.03);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    }

    body {
      background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
      color: var(--light);
      min-height: 100vh;
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 0 20px;
    }

    .kv a {
      color: #7B7B7B;
    }

    .history-hash a {
      color: #7B7B7B;
    }

    /* Header Styles */
    header {
      padding: 20px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo-icon {
      width: 60px;
      height: 60px;
      /* background: linear-gradient(135deg, var(--primary), var(--secondary)); */
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 18px;
    }

    .logo-text {
      font-size: 24px;
      font-weight: 700;
      background: linear-gradient(to right, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .wallet-connect {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    /* Site Navigation */
    .site-nav {
      display: flex;
      align-items: center;
      gap: 16px;
    }

    .nav-links {
      display: flex;
      align-items: center;
      gap: 18px;
    }

    .nav-links a {
      color: var(--text-color);
      text-decoration: none;
      font-weight: 600;
      opacity: 0.9;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 8px 12px;
      min-height: 48px;
      border-radius: 8px;
      transition: var(--transition);
    }

    .nav-links a:hover {
      background: rgba(255, 255, 255, 0.06);
      opacity: 1;
    }

    /* Hamburger (mobile) */
    .hamburger {
      display: none;
      width: 48px;
      height: 48px;
      border-radius: 10px;
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0.1);
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .hamburger:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(108, 56, 255, 0.4);
    }

    .hamburger .bars {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .hamburger .bars span {
      width: 24px;
      height: 2px;
      background: white;
      border-radius: 2px;
      transition: transform 0.3s ease, opacity 0.3s ease, background-color 0.2s ease;
    }

    .hamburger:hover {
      background: rgba(255, 255, 255, 0.06);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .hamburger.active .bars span:nth-child(1) {
      transform: translateY(7px) rotate(45deg);
    }

    .hamburger.active .bars span:nth-child(2) {
      opacity: 0;
    }

    .hamburger.active .bars span:nth-child(3) {
      transform: translateY(-7px) rotate(-45deg);
    }

    /* Mobile nav panel */
    .mobile-nav {
      position: fixed;
      top: 0;
      right: 0;
      height: 100%;
      width: 250px;
      background: var(--dark);
      border-left: 1px solid rgba(255, 255, 255, 0.1);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 1100;
      padding: 20px;
      box-shadow: -5px 0 15px rgba(0, 0, 0, 0.2);
      display: none;
    }

    .mobile-nav.open {
      transform: translateX(0);
    }

    .mobile-nav a {
      display: flex;
      align-items: center;
      min-height: 48px;
      padding: 12px 16px;
      color: var(--text-color);
      text-decoration: none;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .mobile-nav a:last-child {
      border-bottom: none;
    }

    /* Wallet mobile address */
    .wallet-address-mobile {
      font-size: 12px;
      color: var(--darker);
      margin-left: 6px;
    }

    .wallet-info {
      display: flex;
      align-items: center;
      gap: 10px;
      background: var(--card-bg);
      padding: 10px 15px;
      border-radius: var(--border-radius);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .wallet-status {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 14px;
    }

    .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--error);
    }

    .status-indicator.connected {
      background: var(--success);
    }

    .wallet-address {
      font-family: monospace;
      font-size: 14px;
      color: var(--gray);
    }

    /* Main Content */
    .main-content {
      padding: 40px 0;
    }

    .page-title {
      text-align: center;
      margin-bottom: 40px;
    }

    .page-title h1 {
      font-size: 36px;
      margin-bottom: 10px;
      background: linear-gradient(to right, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
    }

    .page-title p {
      color: var(--gray);
      max-width: 600px;
      margin: 0 auto;
    }

    /* Tabs Navigation */
    .tabs {
      display: flex;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 8px;
      margin-bottom: 25px;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .tab {
      flex: 1;
      padding: 14px 20px;
      text-align: center;
      border-radius: 12px;
      cursor: pointer;
      transition: var(--transition);
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .tab:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .tab.active {
      background: var(--primary);
      box-shadow: 0 4px 12px rgba(108, 56, 255, 0.3);
    }

    /* Tab Content */
    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.5s ease;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Card Styles */
    .card {
      margin: 0 0 20px;
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 25px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: var(--transition);
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }

    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
    }

    .card-header {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .card-icon {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .airtime-icon {
      background: linear-gradient(135deg, var(--primary), #8A5CFF);
    }

    .data-icon {
      background: linear-gradient(135deg, var(--secondary), #00A3FF);
    }

    .card-title {
      font-size: 22px;
      font-weight: 600;
    }

    /* Form Elements */
    .form-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 15px;
    }

    .form-group {
      margin-bottom: 15px;
    }

    .form-group.full-width {
      grid-column: 1 / -1;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-size: 14px;
      font-weight: 500;
      color: var(--gray);
    }

    input,
    select {
      width: 100%;
      padding: 14px 16px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.2);
      color: var(--light);
      font-size: 16px;
      transition: var(--transition);
    }

    input:focus,
    select:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 2px rgba(108, 56, 255, 0.2);
    }

    input[readonly] {
      background: rgba(0, 0, 0, 0.3);
      color: var(--gray);
    }

    .divider {
      height: 1px;
      background: rgba(255, 255, 255, 0.1);
      margin: 20px 0;
    }

    /* Buttons */
    .button-group {
      display: flex;
      gap: 12px;
      margin-top: 20px;
    }

    .btn {
      padding: 14px 24px;
      border-radius: 10px;
      border: none;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      color: white;
      flex: 1;
    }

    .btn-mini {
      padding: 0 12px;
      height: 52px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(0, 0, 0, 0.2);
      color: var(--light);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      transition: var(--transition);
      flex-shrink: 0;
    }

    .btn-mini:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--primary);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(108, 56, 255, 0.4);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.1);
      color: var(--light);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none !important;
    }

    /* Status Messages */
    .status-message {
      margin-top: 15px;
      padding: 12px 16px;
      border-radius: 10px;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .status-success {
      background: rgba(0, 216, 151, 0.1);
      border: 1px solid rgba(0, 216, 151, 0.3);
      color: var(--success);
    }

    .status-error {
      background: rgba(255, 71, 87, 0.1);
      border: 1px solid rgba(255, 71, 87, 0.3);
      color: var(--error);
    }

    /* Tips Section */
    .tips-section {
      background: var(--card-bg);
      border-radius: var(--border-radius);
      padding: 25px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      margin-top: 30px;
    }

    .tips-title {
      font-size: 20px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .tips-list {
      list-style: none;
    }

    .tips-list li {
      padding: 10px 0;
      display: flex;
      align-items: flex-start;
      gap: 12px;
    }

    .tips-list li:before {
      content: "â€¢";
      color: var(--primary);
      font-size: 20px;
    }

    /* Responsive Design */
    @media (max-width: 768px) {
      .form-grid {
        grid-template-columns: 1fr;
      }

      .logo {
        position: absolute;
        left: 5px;
        margin-top: 20px;
      }

      .header-content {
        flex-direction: column;
        gap: 15px;
      }

      .wallet-connect {
        width: 100%;
        justify-content: center;
      }

      .button-group {
        flex-direction: column;
      }

    }

    /* Animation for loading */
    @keyframes pulse {
      0% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }

      100% {
        opacity: 1;
      }
    }

    .loading {
      animation: pulse 1.5s infinite;
    }

    .wallet-connect {
      position: relative;
      display: flex;
      gap: 12px;
      align-items: center;
    }

    .wallet-select {
      appearance: none;
      -webkit-appearance: none;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      color: var(--light);
      padding: 0 36px 0 14px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      outline: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12' fill='none'%3E%3Cpath d='M2.5 4.5L6 8L9.5 4.5' stroke='white' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      transition: all 0.2s ease;
      height: 42px;
      display: flex;
      align-items: center;
    }

    .wallet-select:hover {
      background-color: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .wallet-select option {
      background: #1a1b23;
      color: white;
    }

    .wallet-dropdown {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      background: var(--dark);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
      min-width: 220px;
      display: none;
      z-index: 1000;
    }

    .wallet-dropdown.open {
      display: block;
    }

    .wallet-dropdown-header {
      padding: 10px 12px;
      font-weight: 600;
      color: var(--gray);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .wallet-option {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 12px;
      cursor: pointer;
      transition: var(--transition);
    }

    .wallet-option:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .wallet-option .icon {
      width: 24px;
      height: 24px;
      border-radius: 6px;
      background: var(--primary);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    .btn.connected {
      background: var(--success);
      color: #052b1e;
      border-color: rgba(0, 0, 0, 0.2);
    }

    .auth-steps {
      display: inline-flex;
      gap: 6px;
      align-items: center;
      margin-left: 8px;
    }

    .auth-steps .step {
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      color: var(--gray);
      background: rgba(255, 255, 255, 0.03);
    }

    .auth-steps .step.completed {
      color: var(--success);
      border-color: var(--success);
      background: rgba(46, 204, 113, 0.08);
    }

    .auth-steps .step.error {
      color: var(--error);
      border-color: var(--error);
      background: rgba(231, 76, 60, 0.08);
    }

    /* Alert modal */
    .alert-modal {
      top: 280%;
      position: fixed;
      inset: 0;
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
    }

    .alert-backdrop {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
    }

    .alert-content {
      position: relative;
      width: 90%;
      max-width: 420px;
      background: #330C09;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 16px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      padding: 24px;
      color: var(--text-color);
      animation: alertPop 0.3s cubic-bezier(0.16, 1, 0.3, 1);
    }

    @keyframes alertPop {
      from {
        transform: scale(0.95);
        opacity: 0;
      }

      to {
        transform: scale(1);
        opacity: 1;
      }
    }

    .alert-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 16px;
    }

    .alert-header #alert-title {
      font-size: 18px;
      font-weight: 600;
    }

    .alert-message {
      font-size: 15px;
      color: var(--gray);
      margin: 0 0 24px;
      line-height: 1.5;
    }

    .alert-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .btn.btn-link {
      background: transparent;
      border: none;
      color: var(--gray);
      padding: 6px;
      cursor: pointer;
    }

    /* Mobile responsiveness improvements */
    .wallet-connect .btn {
      min-height: 48px;
      padding: 10px 14px;
      font-size: 14px;
    }

    .wallet-option {
      min-height: 48px;
    }

    .wallet-option .icon {
      font-size: 16px;
    }

    .auth-steps {
      flex-wrap: wrap;
    }

    .auth-steps .step {
      line-height: 1;
    }

    @media (max-width: 768px) {
      .wallet-connect {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }

      .auth-steps {
        justify-content: center;
        margin-left: 0;
      }

      .wallet-dropdown {
        left: 0;
        right: 0;
        width: 100%;
        max-width: none;
      }

      .alert-content {
        margin: 40px 12px;
        max-width: none;
      }

      .nav-links {
        display: none;
      }

      .hamburger {
        display: inline-flex;
        position: fixed;
        top: 12px;
        right: 12px;
        z-index: 1200;
      }

      .mobile-nav {
        display: none;
        /* margin-top: 114px; */
        position: fixed;
        top: 0;
        right: 0;
        height: 500%;
        width: 260px;
        transform: translateX(100%);
        transition: transform 0.3s ease;
      }

      .mobile-nav.open {
        transform: translateX(0);
      }

      .header-content {
        padding-right: 62px;
        padding-left: 62px;
        margin-top: -22px;
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .hamburger .bars span {
        transition: none;
      }

      .mobile-nav {
        transition: none;
      }
    }

    @media (max-width: 480px) {
      .wallet-connect .btn {
        min-height: 48px;
        font-size: 13px;
        padding: 10px 12px;
      }

      .auth-steps .step {
        font-size: 11px;
        padding: 4px 6px;
      }

      .wallet-option {
        padding: 10px;
      }

      .tabs {
        flex-direction: column;
      }
    }

    /* Button Loading State */
    .btn.loading {
      position: relative;
      pointer-events: none;
      opacity: 0.8;
      cursor: not-allowed;
    }

    .btn.loading .spinner {
      display: inline-block;
      width: 1em;
      height: 1em;
      border: 2px solid currentColor;
      border-radius: 50%;
      border-top-color: transparent;
      animation: spin 1s linear infinite;
      margin-right: 0.5em;
      vertical-align: middle;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }

    /* Custom wallet dropdown and connect UI */
    /* Transaction Receipts */
    .receipts-container {
      margin-top: 24px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 16px;
    }

    @media (min-width: 992px) {
      .receipts-container {
        grid-template-columns: 1fr 1fr;
      }
    }

    .receipt-card {
      background: var(--card-bg);
      border: 1px solid rgba(255, 255, 255, 0);
      border-radius: var(--border-radius);
      overflow: hidden;
    }

    .receipt-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px 16px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .receipt-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-weight: 600;
    }

    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 13px;
      font-weight: 600;
    }

    .status-success {
      background: rgba(0, 216, 151, 0.15);
      color: #00D897;
      border: 1px solid rgba(0, 216, 151, 0.35);
    }

    .status-failed {
      background: rgba(255, 71, 87, 0.15);
      color: #FF4757;
      border: 1px solid rgba(255, 71, 87, 0.35);
    }

    .status-pending {
      background: rgba(255, 181, 71, 0.15);
      color: #FFB547;
      border: 1px solid rgba(255, 181, 71, 0.35);
    }

    .receipt-body {
      padding: 14px 16px;
    }

    .receipt-grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px 16px;
    }

    @media (min-width: 768px) {
      .receipt-grid {
        grid-template-columns: 1fr 1fr;
      }
    }

    .kv {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .kv .k {
      color: var(--gray);
      min-width: 120px;
    }

    .kv .v {
      font-family: monospace;
      font-size: 13px;
      word-break: break-all;
    }

    .receipt-footer {
      border-top: 1px solid rgba(255, 255, 255, 0.08);
      padding: 12px 16px;
      display: flex;
      gap: 8px;
      justify-content: flex-end;
    }

    /* Print styles */
    @media print {
      body {
        background: #fff;
        color: #000;
      }

      header,
      .tabs,
      .tips-section,
      .button-group,
      #airtime-status,
      #data-status {
        display: none !important;
      }

      .receipt-card {
        break-inside: avoid;
        border-color: #000;
      }
    }
  </style>
  <!-- MetaMask / EVM only -->
  <style>
    /* Loading Overlay */
    #global-loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.15);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    #global-loader.visible {
      opacity: 1;
      pointer-events: all;
    }

    .loader-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 255, 255, 0.1);
      border-left-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 16px;
    }

    .loader-text {
      color: var(--light);
      font-size: 18px;
      font-weight: 500;
      letter-spacing: 0.5px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>
  <header>
    <div class="container">
      <div class="header-content">
        <div class="logo">
          <a class="logo-icon" href="../index.html" aria-label="Assetchain DEX Home">
            <img src="../assets/img/favicon.png" alt="Assetchain DEX Logo"
              style="width: 100%; height: 100%; object-fit: contain;">
          </a>
          <!-- <div class="logo-text">Assetchain DEX</div> -->
        </div>
        <nav class="site-nav" aria-label="Primary Navigation">
          <ul class="nav-links">
            <li><a href="../index.html">Home</a></li>
            <li><a href="../app/home/index.php">CEX App</a></li>
            <li><a href="../app/home/about-us.php">About</a></li>
          </ul>
          <button id="hamburger" class="hamburger" aria-label="Open menu" aria-expanded="false"
            aria-controls="mobile-nav">
            <div class="bars"><span></span><span></span><span></span></div>
          </button>
        </nav>
        <div class="wallet-connect">
          <!-- Hidden chain tracking (JavaScript managed) -->
          <input type="hidden" id="chain-select" value="assetchain">
          <!-- <select id="chain-select" class="form-select" aria-label="Chain selector">
          <option value="Bitget">Bitget Wallet</option>
          <option value="OKX">OKX Wallet</option>
          </select> -->
          <button id="onboard-connect-btn" class="btn btn-secondary">
            <i class="fas fa-wallet"></i> Connect Wallet
          </button>
          <div id="auth-steps" class="auth-steps" aria-live="polite">
            <span class="step step-connect" data-step="connect" title="Wallet connection step">Connect</span>
            <span class="step step-network" data-step="network" title="Assetchain network step">Network</span>
            <span class="step step-signin" data-step="signin" title="Sign-in step">Sign-in</span>
            <button id="theme-toggle" aria-label="Toggle theme">
              <i class="fas fa-sun"></i>
            </button>
          </div>
          <button id="sign-in-btn" class="btn btn-primary" style="display:none;margin-left:8px;">
            <i class="fas fa-user-check"></i> Sign In
          </button>

          <div id="alert-modal" class="alert-modal" aria-hidden="true" role="dialog" aria-modal="true"
            style="display:none; top:280%;">
            <div class="alert-backdrop"></div>
            <div class="alert-content" role="document">
              <div class="alert-header">
                <span id="alert-title">Notice</span>
                <button id="alert-close" class="btn btn-link" aria-label="Close"><i class="fas fa-times"></i></button>
              </div>
              <div id="alert-message" class="alert-message"></div>
              <div class="alert-actions">
                <button id="alert-cancel" class="btn btn-secondary" style="display:none;">Cancel</button>
                <button id="alert-ok" class="btn btn-primary">OK</button>
              </div>
            </div>
          </div>
          <div id="wallet-dropdown" class="wallet-dropdown" role="menu" aria-label="Connection options">
            <!-- Chain Selection Section (shown first) -->
            <div id="chain-selection" class="dropdown-section">
              <div class="wallet-dropdown-header">Select Chain</div>
              <div class="wallet-option chain-option" data-chain="assetchain">
                <span class="icon" style="background: linear-gradient(135deg, #d9e5ec, #55d7ee);">
                  <img src="https://swap.assetchain.org/assets/assetChainWhite-CKHIdwHO.ico" width="18"
                    onerror="this.style.display='none'">
                </span>
                <span>AssetChain</span>
              </div>
              <div class="wallet-option chain-option" data-chain="base">
                <span class="icon" style="background: linear-gradient(135deg, #0052FF, #0066FF);">
                  <img src="https://avatars.githubusercontent.com/u/108554348?s=200&v=4" width="18">
                </span>
                <span>Base</span>
              </div>
              <div class="wallet-option chain-option" data-chain="arbitrum">
                <span class="icon" style="background: linear-gradient(135deg, #28A0F0, #1C7ED6);">
                  <img src="https://cryptologos.cc/logos/arbitrum-arb-logo.png" width="18">
                </span>
                <span>Arbitrum</span>
              </div>
              <div class="wallet-option chain-option" data-chain="bsc">
                <span class="icon" style="background: linear-gradient(135deg, #F3BA2F, #E6A800);">
                  <img src="https://cryptologos.cc/logos/bnb-bnb-logo.png" width="18">
                </span>
                <span>BNB Chain</span>
              </div>
              <div class="wallet-option" id="chain-back-btn"
                style="display:none; border-top:1px solid rgba(255,255,255,0.1);">
                <span class="icon" style="background: var(--gray);"><i class="fas fa-arrow-left"></i></span>
                <span>Back</span>
              </div>
            </div>
            <!-- Wallet Selection Section (shown after chain selected) -->
            <div id="wallet-selection" class="dropdown-section" style="display:none;">
              <div class="wallet-dropdown-header">Select Wallet <span id="selected-chain-label"
                  style="font-size:12px;color:var(--primary);margin-left:8px;"></span></div>
              <div class="wallet-option" data-wallet="MetaMask">
                <span class="icon"><img
                    src="https://images.ctfassets.net/clixtyxoaeas/4rnpEzy1ATWRKVBOLxZ1Fm/a74dc1eed36d23d7ea6030383a4d5163/MetaMask-icon-fox.svg"
                    width="18"></span>
                <span>MetaMask</span>
              </div>
              <div class="wallet-option" data-wallet="Bitget">
                <span class="icon"><img
                    src="https://play-lh.googleusercontent.com/QbNP8A9GE_UM1s3RFNF8i599yWm_F37iwL4viYCueD9XhJaIZ2yZjMnEwsegeTaHa7Q=w240-h480-rw"
                    width="18"></span>
                <span>Bitget Wallet</span>
              </div>
              <div class="wallet-option" data-wallet="OKX">
                <span class="icon"><img
                    src="https://play-lh.googleusercontent.com/N00SbjLJJrhg4hbdnkk3Llk2oedNNgCU29DvR9cpep7Lr0VkzvBkmLqajWNgFb0d7IOO"
                    width="18"></span>
                <span>OKX Wallet</span>
              </div>
              <div class="wallet-option" id="wallet-back-btn" style="border-top:1px solid rgba(255,255,255,0.1);">
                <span class="icon" style="background: var(--gray);"><i class="fas fa-arrow-left"></i></span>
                <span>Back to Chains</span>
              </div>
              <div id="wallet-disconnect-option" class="wallet-option" data-wallet="__disconnect__"
                style="display:none;border-top:1px solid rgba(255,255,255,0.1);">
                <span class="icon" style="background: var(--error);"><i class="fas fa-sign-out-alt"></i></span>
                <span>Disconnect</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="mobile-nav" class="mobile-nav" role="menu" aria-label="Mobile Navigation">
        <a href="../index.html">Home</a>
        <a href="../app/home/index.php">CEX App</a>
        <a href="../app/home/about-us.php">About</a>
      </div>
    </div>
  </header>

  <!-- Wallet selection UI handled by custom dropdown -->

  <main class="main-content">
    <div class="container">
      <div class="page-title">
        <h1>Buy Airtime & Data with CNGN</h1>
        <p>Purchase mobile airtime and data plans instantly using CNGN on Assetchain. Fast, secure, and decentralized.
        </p>
      </div>

      <!-- Tabs Navigation -->
      <div class="tabs">
        <div class="tab active" data-tab="airtime">
          <i class="fas fa-phone-alt"></i>
          Airtime
        </div>
        <div class="tab" data-tab="data">
          <i class="fas fa-wifi"></i>
          Data
        </div>
        <div class="tab" data-tab="history">
          <i class="fas fa-list"></i>
          History
        </div>
      </div>

      <!-- Airtime Tab Content -->
      <div class="tab-content active" id="airtime-tab">
        <div class="card">
          <div class="card-header">
            <div class="card-icon airtime-icon">
              <i class="fas fa-phone-alt"></i>
            </div>
            <h2 class="card-title">Airtime Top-up</h2>
          </div>

          <div class="form-grid">
            <div class="form-group">
              <label for="airtime-network">Network Provider</label>
              <select id="airtime-network"></select>
            </div>

            <div class="form-group">
              <label for="airtime-phone">Phone Number</label>
              <input id="airtime-phone" type="tel" placeholder="e.g. 08012345678" required />
            </div>
            <div class="form-group checkbox-group"
              style="flex-direction: row; align-items: center; gap: 10px; margin-top: -10px; margin-bottom: 10px;">
              <input id="airtime-ported" type="checkbox" aria-label="Is this a ported number?"
                style="width: auto; margin: 0;" />
              <label for="airtime-ported" style="margin-bottom: 0; cursor: pointer;">Is Ported Number</label>
            </div>

            <div class="form-group">
              <label for="airtime-amount">Amount (NGN)</label>
              <input id="airtime-amount" type="number" min="50" step="10" placeholder="100" required />
            </div>

            <!-- <div class="form-group"> -->
            <!-- <label for="airtime-ref">Reference ID</label> -->
            <input id="airtime-ref" class="mono" required readonly hidden />
            <!-- </div> -->
            <div class="form-group">
              <label for="airtime-token">Token</label>
              <div style="display: flex; gap: 8px;">
                <select id="airtime-token" aria-label="Select token" style="flex: 1;"></select>
                <button type="button" class="btn-mini" onclick="addTokenToWallet('airtime-token')"
                  title="Add token to wallet">
                  <i class="fas fa-wallet"></i> Add
                </button>
              </div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="form-grid">
            <input id="airtime-target" class="mono" placeholder="Site EVM receiving address" readonly hidden required />
            <input id="airtime-nano" class="mono" placeholder="Auto-calculated" required readonly hidden />

            <div class="form-group">
              <label for="airtime-display">Amount (Selected Currency)</label>
              <input id="airtime-display" class="mono" placeholder="Auto-calculated" readonly />
            </div>
          </div>

          <div class="button-group">
            <button id="airtime-calc" class="btn btn-secondary">
              <i class="fas fa-calculator"></i> Calculate Amount
            </button>
            <button id="airtime-send" class="btn btn-primary" style="display:none;" disabled>
              <i class="fas fa-paper-plane"></i> Buy
            </button>
            <button id="airtime-reset" class="btn btn-secondary">
              <i class="fas fa-redo"></i> Reset
            </button>
          </div>

          <div id="airtime-status"></div>
        </div>
        <div class="tips-section">
          <h3 class="tips-title"><i class="fas fa-lightbulb"></i> How It Works</h3>
          <ul class="tips-list">
            <li>Use the Account Center to connect and manage your wallet</li>
            <li>Select your network provider and enter your phone number</li>
            <li>Choose the amount (for airtime) or data plan you want to purchase</li>
            <li>Calculate the CNGN amount and send the payment</li>
            <li>Your transaction will be verified on-chain and your airtime/data will be delivered</li>
            <li>All transactions are secure and processed on the Assetchain network</li>
          </ul>
        </div>

      </div>

      <!-- Data Tab Content -->
      <div class="tab-content" id="data-tab">
        <div class="card">
          <div class="card-header">
            <div class="card-icon data-icon">
              <i class="fas fa-wifi"></i>
            </div>
            <h2 class="card-title">Data Plans</h2>
          </div>

          <div class="form-grid">
            <div class="form-group">
              <label for="data-network">Network Provider</label>
              <select id="data-network"></select>
            </div>

            <div class="form-group">
              <label for="data-plan">Data Plan</label>
              <select id="data-plan"></select>
            </div>
            <input id="data-nano" type="text" hidden />

            <div class="form-group">
              <label for="data-phone">Phone Number</label>
              <input id="data-phone" type="tel" placeholder="e.g. 08012345678" />
            </div>
            <div class="form-group checkbox-group"
              style="flex-direction: row; align-items: center; gap: 10px; margin-top: -10px; margin-bottom: 10px;">
              <input id="data-ported" type="checkbox" aria-label="Is this a ported number?"
                style="width: auto; margin: 0;" />
              <label for="data-ported" style="margin-bottom: 0; cursor: pointer;">Is Ported Number</label>
            </div>

            <!-- <div class="form-group"> -->
            <!-- <label for="data-ref">Reference ID</label> -->
            <input id="data-ref" class="mono" readonly hidden />
            <!-- </div> -->
            <div class="form-group">
              <label for="data-token">Token</label>
              <div style="display: flex; gap: 8px;">
                <select id="data-token" aria-label="Select token" style="flex: 1;"></select>
                <button type="button" class="btn-mini" onclick="addTokenToWallet('data-token')"
                  title="Add token to wallet">
                  <i class="fas fa-wallet"></i> Add
                </button>
              </div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="form-grid">
            <!-- <div class="form-group"> -->
            <!-- <label for="data-target">Receiving EVM Address</label> -->
            <input id="data-target" class="mono" placeholder="Site EVM receiving address" readonly hidden />
            <!-- </div> -->

            <div class="form-group">
              <label for="data-display">Amount (Selected Currency)</label>
              <input id="data-display" class="mono" placeholder="Auto-calculated" readonly />
            </div>

            <div class="button-group">
              <button id="data-calc" class="btn btn-secondary">
                <i class="fas fa-calculator"></i> Calculate Amount
              </button>
              <button id="data-send" class="btn btn-primary" style="display:none;" disabled>
                <i class="fas fa-paper-plane"></i> Buy
              </button>
              <button id="data-reset" class="btn btn-secondary">
                <i class="fas fa-redo"></i> Reset
              </button>
            </div>

            <div id="data-status"></div>
          </div>
        </div>

        <!-- History Tab Content -->

        <div class="tips-section">
          <h3 class="tips-title"><i class="fas fa-lightbulb"></i> How It Works</h3>
          <ul class="tips-list">
            <li>Use the Account Center to connect and manage your wallet</li>
            <li>Select your network provider and enter your phone number</li>
            <li>Choose the amount (for airtime) or data plan you want to purchase</li>
            <li>Calculate the CNGN amount and send the payment</li>
            <li>Your transaction will be verified on-chain and your airtime/data will be delivered</li>
            <li>All transactions are secure and processed on the Assetchain network</li>
          </ul>
        </div>

        <div id="tx-receipts" class="receipts-container" aria-live="polite" aria-label="Transaction receipts"></div>
      </div>
      <div class="tab-content" id="history-tab">
        <div id="history-card" class="card" style="display:none;" aria-live="polite" aria-label="Transaction history">
          <div class="card-header">
            <div class="card-icon" style="background: linear-gradient(135deg, var(--secondary), var(--accent));">
              <i class="fas fa-list"></i>
            </div>
            <h2 class="card-title">Your Transaction History</h2>
          </div>
          <div class="history-controls" role="region" aria-label="History controls">
            <div class="form-grid">
              <div class="form-group">
                <label for="history-sort">Sort By</label>
                <select id="history-sort" aria-label="Sort transactions">
                  <option value="date_desc">Date (Newest)</option>
                  <option value="date_asc">Date (Oldest)</option>
                  <option value="amount_desc">Amount (High)</option>
                  <option value="amount_asc">Amount (Low)</option>
                  <option value="status">Status</option>
                </select>
              </div>
              <div class="form-group">
                <label for="history-filter">Filter</label>
                <select id="history-filter" aria-label="Filter transactions">
                  <option value="all">All</option>
                  <option value="confirmed">Confirmed</option>
                  <option value="pending">Pending</option>
                  <option value="failed">Failed</option>
                  <option value="refunded">Refunded</option>
                </select>
              </div>
              <div class="form-group">
                <label for="history-reload">Actions</label>
                <button id="history-reload" class="btn btn-secondary" style="width:100%" aria-label="Reload history">
                  <i class="fas fa-sync-alt"></i> Reload History
                </button>
              </div>
            </div>
          </div>
          <div id="history-status" class="mono" aria-live="polite"></div>
          <div id="history-list" class="history-list"></div>
          <div class="history-pagination" role="navigation" aria-label="Pagination controls">
            <button id="history-prev" class="btn btn-secondary" disabled aria-label="Previous page"><i
                class="fas fa-chevron-left"></i> Prev</button>
            <span id="history-page" class="mono" aria-live="polite"></span>
            <button id="history-next" class="btn btn-secondary" disabled aria-label="Next page">Next <i
                class="fas fa-chevron-right"></i></button>
          </div>
        </div>
      </div>

      <div id="tx-modal" class="tx-modal" style="display:none;" aria-hidden="true" role="dialog" aria-modal="true">
        <div class="tx-backdrop"></div>
        <div class="tx-content" role="document">
          <div class="tx-header">
            <h3 id="tx-modal-title">Transaction Details</h3>
            <button id="tx-modal-close" class="btn btn-link" aria-label="Close"><i class="fas fa-times"></i></button>
          </div>
          <div id="tx-modal-body" class="tx-body"></div>
        </div>
      </div>
  </main>

  <script>
    // Custom wallet provider detection and dropdown UI
    // DOM utility functions
    const $ = (s) => document.querySelector(s);
    const $$ = (s) => document.querySelectorAll(s);
    // const apiBase = '/onchain_multichain/api';
    const apiBase = '/api';

    const CHAINS = {
      assetchain: {
        chainId: '0xa5b4',
        chainName: 'AssetChain Mainnet',
        nativeCurrency: { name: 'ASET', symbol: 'ASET', decimals: 18 },
        rpcUrls: ['https://mainnet-rpc.assetchain.org/'],
        blockExplorerUrls: ['https://scan.assetchain.org'],
        useMoralis: false
      },
      base: {
        chainId: '0x2105',
        chainName: 'Base Mainnet',
        nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
        rpcUrls: ['https://mainnet.base.org'],
        blockExplorerUrls: ['https://basescan.org'],
        useMoralis: true
      },
      arbitrum: {
        chainId: '0xa4b1',
        chainName: 'Arbitrum One',
        nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
        rpcUrls: ['https://arb1.arbitrum.io/rpc'],
        blockExplorerUrls: ['https://arbiscan.io'],
        useMoralis: true
      },
      bsc: {
        chainId: '0x38',
        chainName: 'BNB Smart Chain',
        nativeCurrency: { name: 'BNB', symbol: 'BNB', decimals: 18 },
        rpcUrls: ['https://bsc-dataseed.binance.org/'],
        blockExplorerUrls: ['https://bscscan.com'],
        useMoralis: true
      }
    };

    function getSelectedChain() {
      // First check localStorage, then hidden input, then default
      const saved = localStorage.getItem('dex_selected_chain');
      if (saved && CHAINS[saved]) return saved;
      return document.getElementById('chain-select')?.value || 'assetchain';
    }

    function setSelectedChain(chainKey) {
      if (!chainKey || !CHAINS[chainKey]) return;
      const chainSelect = document.getElementById('chain-select');
      if (chainSelect) chainSelect.value = chainKey;
      localStorage.setItem('dex_selected_chain', chainKey);
      window.selectedChain = chainKey;
    }


    // Web3Onboard removed; using custom wallet dropdown and EIP-1193 providers

    // Tab functionality
    function initTabs() {
      const tabs = $$('.tab');
      const tabContents = $$('.tab-content');

      tabs.forEach(tab => {
        tab.addEventListener('click', () => {
          const tabId = tab.getAttribute('data-tab');

          // Remove active class from all tabs and contents
          tabs.forEach(t => t.classList.remove('active'));
          tabContents.forEach(c => c.classList.remove('active'));

          // Add active class to clicked tab and corresponding content
          tab.classList.add('active');
          $(`#${tabId}-tab`).classList.add('active');

          if (tabId === 'history' && typeof loadHistoryIfEligible === 'function') {
            loadHistoryIfEligible();
          }
        });
      });
    }

    // Onboard initialization is triggered after libraries load above

    // Helper to reduce technical error messages to their core meaning
    function cleanErrorMessage(msg) {
      if (!msg) return '';
      const s = String(msg);

      // Priority 1: Human readable common errors
      if (s.includes('user rejected transaction')) return 'User rejected transaction';
      if (s.includes('User denied transaction')) return 'User denied transaction';
      if (s.includes('insufficient funds')) return 'Insufficient funds';
      if (s.includes('scanner_unreachable')) return 'Scanner unreachable';

      // Priority 2: EVM Reverts
      if (s.includes('execution reverted')) {
        const reason = s.match(/execution reverted:? (.*)/);
        if (reason && reason[1]) {
          let r = reason[1];
          // Clean up if it looks like "reason", code=...
          if (r.includes('",')) {
            r = r.split('",')[0];
            if (r.startsWith('"')) r = r.slice(1);
          } else if (r.startsWith('"') && r.endsWith('"')) {
            r = r.slice(1, -1);
          }
          return 'Execution reverted: ' + r;
        }
        return 'Execution reverted';
      }

      // Priority 3: Technical codes
      const codeMatch = s.match(/code=([A-Z_]+)/);
      if (codeMatch && codeMatch[1]) return codeMatch[1];

      return s;
    }

    // Manual connect button handler (programmatic connect; no Account Center UI)
    // Safe notification helper with responsive toast configuration
    function notify(type, message) {
      const cleanMsg = cleanErrorMessage(message);
      try {
        if (window.toastr) {
          const isMobile = window.matchMedia('(max-width: 576px)').matches;
          toastr.options = {
            positionClass: isMobile ? 'toast-top-center' : 'toast-bottom-right',
            timeOut: 3500,
            extendedTimeOut: 2000,
            closeButton: true,
            progressBar: true,
            newestOnTop: true,
            preventDuplicates: true,
          };
          const fn = typeof toastr[type] === 'function' ? toastr[type] : toastr.info;
          fn(cleanMsg);
        } else {
          const level = type === 'error' ? 'error' : 'log';
          console[level](cleanMsg);
        }
      } catch (_) {
        console.log(cleanMsg);
      }
    }

    // Light alert/confirm modal for critical errors or confirmations
    function showAlert(title, message, options) {
      const cleanMsg = cleanErrorMessage(message);
      return new Promise((resolve) => {
        const modal = document.getElementById('alert-modal');
        const elTitle = document.getElementById('alert-title');
        const elMsg = document.getElementById('alert-message');
        const btnOk = document.getElementById('alert-ok');
        const btnCancel = document.getElementById('alert-cancel');
        const btnClose = document.getElementById('alert-close');
        if (!modal || !elTitle || !elMsg || !btnOk || !btnCancel || !btnClose) {
          alert(cleanMsg || '');
          resolve(true);
          return;
        }
        const opts = options || {};
        elTitle.textContent = title || 'Notice';
        elMsg.textContent = cleanMsg || '';
        const isConfirm = opts.type === 'confirm';
        btnCancel.style.display = isConfirm ? 'inline-flex' : 'none';
        btnOk.textContent = isConfirm ? (opts.confirmText || 'Confirm') : (opts.okText || 'OK');

        const cleanup = () => {
          modal.style.display = 'none';
          modal.setAttribute('aria-hidden', 'true');
          document.removeEventListener('keydown', onKey);
        };
        const onKey = (ev) => { if (ev.key === 'Escape') { cleanup(); resolve(false); } };
        document.addEventListener('keydown', onKey);

        btnOk.onclick = () => { cleanup(); resolve(true); };
        btnCancel.onclick = () => { cleanup(); resolve(false); };
        btnClose.onclick = () => { cleanup(); resolve(false); };
        const backdrop = modal.querySelector('.alert-backdrop');
        if (backdrop) backdrop.onclick = () => { cleanup(); resolve(false); };

        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
      });
    }

    function confirmDialog(title, message, opts) {
      return showAlert(title, message, { ...(opts || {}), type: 'confirm' });
    }

    // Resolve a provider by selected wallet name using EIP-6963 info and common flags
    function resolveProviderBySelection(name) {
      const providers = Array.isArray(window.availableInjectedProviders) ? window.availableInjectedProviders : [];
      const matchInfo = (pred) => providers.find(p => {
        const infoName = (p.info?.name || '').toLowerCase();
        const rdns = (p.info?.rdns || '').toLowerCase();
        return pred(infoName, rdns);
      });

      let infoMatch;
      if (name === 'MetaMask') {
        infoMatch = matchInfo((n, r) => n.includes('metamask') || r.includes('io.metamask'));
      } else if (name === 'OKX') {
        infoMatch = matchInfo((n, r) => n.includes('okx') || r.includes('com.okex') || r.includes('com.okx'));
      } else if (name === 'Bitget') {
        infoMatch = matchInfo((n, r) => n.includes('bitget') || n.includes('bitkeep') || r.includes('com.bitget') || r.includes('com.bitkeep'));
      }
      if (infoMatch) return infoMatch.provider;

      const eth = window.ethereum;
      if (eth) {
        if (name === 'MetaMask' && eth.isMetaMask) return eth;
        if (name === 'OKX' && (eth.isOKXWallet || eth.isOkxWallet)) return eth;
        if (name === 'Bitget' && (eth.isBitgetWallet || eth.isBitKeep || eth.isBitkeep)) return eth;
      }
      if (name === 'OKX' && window.okxwallet) return window.okxwallet.ethereum || window.okxwallet;
      if (name === 'Bitget' && window.bitkeep && window.bitkeep.ethereum) return window.bitkeep.ethereum;
      return null;
    }

    function formatAddress(addr) {
      if (!addr || typeof addr !== 'string') return '';
      return addr.slice(0, 6) + 'â€¦' + addr.slice(-4);
    }

    function walletIconHtml(name) {
      const n = (name || '').toLowerCase();
      if (n.includes('metamask')) return '<img src="https://images.ctfassets.net/clixtyxoaeas/4rnpEzy1ATWRKVBOLxZ1Fm/a74dc1eed36d23d7ea6030383a4d5163/MetaMask-icon-fox.svg" width="25" >';
      if (n.includes('okx')) return '<img src="https://play-lh.googleusercontent.com/N00SbjLJJrhg4hbdnkk3Llk2oedNNgCU29DvR9cpep7Lr0VkzvBkmLqajWNgFb0d7IOO" width="25" >';
      if (n.includes('bitget') || n.includes('bitkeep')) return '<img src="https://play-lh.googleusercontent.com/QbNP8A9GE_UM1s3RFNF8i599yWm_F37iwL4viYCueD9XhJaIZ2yZjMnEwsegeTaHa7Q=w240-h480-rw" width="25" >';
      return '<i class="fas fa-wallet"></i>';
    }

    async function getChainId(provider) {
      try {
        const p = provider || window.currentProvider || window.ethereum;
        if (!p) return null;
        const id = await p.request({ method: 'eth_chainId' });
        return (id || '').toLowerCase();
      } catch (_) {
        return null;
      }
    }

    function updateAuthIndicators(state) {
      const s = state || window.authState || {};
      const elConnect = document.querySelector('#auth-steps .step-connect');
      const elNetwork = document.querySelector('#auth-steps .step-network');
      const elSignin = document.querySelector('#auth-steps .step-signin');
      if (elConnect) {
        elConnect.classList.toggle('completed', !!s.connected);
        elConnect.classList.toggle('error', !s.connected);
      }
      if (elNetwork) {
        elNetwork.classList.toggle('completed', !!s.networkOk);
        elNetwork.classList.toggle('error', s.connected && !s.networkOk);
      }
      if (elSignin) {
        elSignin.classList.toggle('completed', !!s.signedIn);
        elSignin.classList.toggle('error', s.networkOk && !s.signedIn);
      }
      const signBtn = document.getElementById('sign-in-btn');
      if (signBtn) {
        signBtn.style.display = s.connected && s.networkOk && !s.signedIn ? 'inline-flex' : 'none';
      }
    }

    async function setConnectedUI(address, walletName) {
      const btn = document.getElementById('onboard-connect-btn');
      const disconnectOpt = document.getElementById('wallet-disconnect-option');
      const chainId = await getChainId();
      const supportedChainIds = Object.values(CHAINS).map(c => c.chainId.toLowerCase());
      const currentChainEntry = Object.entries(CHAINS).find(([k, v]) => v.chainId.toLowerCase() === (chainId || '').toLowerCase());

      if (btn) {
        const short = formatAddress(address);
        const netShort = currentChainEntry ? currentChainEntry[1].chainName.split(' ')[0] : 'Wrong Network';
        const isMobile = window.matchMedia('(max-width: 768px)').matches;
        const icon = walletIconHtml(walletName);
        if (isMobile) {
          btn.innerHTML = `${icon} <span class="wallet-address-mobile">${short}</span>`;
        } else {
          btn.innerHTML = `${icon} ${short} â€¢ ${netShort}`;
        }
        btn.classList.add('connected');
      }
      if (disconnectOpt) {
        disconnectOpt.style.display = 'flex';
      }
      window.authState = {
        ...(window.authState || {}),
        connected: true,
        networkOk: supportedChainIds.includes((chainId || '').toLowerCase()),
        signedIn: !!(window.dexAuth && window.dexAuth.valid),
        address: address,
        wallet: walletName
      };
      updateAuthIndicators();
      loadHistoryIfEligible();
    }

    function setDisconnectedUI() {
      const btn = document.getElementById('onboard-connect-btn');
      const disconnectOpt = document.getElementById('wallet-disconnect-option');
      if (btn) {
        btn.innerHTML = '<i class="fas fa-wallet"></i> Connect Wallet';
        btn.classList.remove('connected');
      }
      if (disconnectOpt) {
        disconnectOpt.style.display = 'none';
      }
      window.authState = { connected: false, networkOk: false, signedIn: false, address: null, wallet: null };
      updateAuthIndicators();
    }

    function subscribeToProvider(provider) {
      try {
        const listeners = window._providerListeners || {};
        // Remove previous listeners
        if (listeners.provider && listeners.accountsChanged && typeof listeners.provider.removeListener === 'function') {
          try { listeners.provider.removeListener('accountsChanged', listeners.accountsChanged); } catch (_) { }
        }
        if (listeners.provider && listeners.chainChanged && typeof listeners.provider.removeListener === 'function') {
          try { listeners.provider.removeListener('chainChanged', listeners.chainChanged); } catch (_) { }
        }
        const onAccountsChanged = (accounts) => {
          const addr = Array.isArray(accounts) ? accounts[0] : null;
          window.currentAddress = addr || window.currentAddress || null;
          if (window.currentAddress) {
            // If session address differs, clear session
            if (window.dexAuth && window.dexAuth.address && window.dexAuth.address.toLowerCase() !== window.currentAddress.toLowerCase()) {
              clearSession();
              window.authState = { ...(window.authState || {}), signedIn: false };
            }
            setConnectedUI(window.currentAddress, window.currentWalletName || 'Wallet');
          }
          else setDisconnectedUI();
        };
        const onChainChanged = async (_) => {
          const currentChainId = (await getChainId() || '').toLowerCase();
          // Check if current chain is one of our supported chains
          const supportedChainIds = Object.values(CHAINS).map(c => c.chainId.toLowerCase());
          const netOk = supportedChainIds.includes(currentChainId);

          window.authState = { ...(window.authState || {}), networkOk: !!netOk };
          updateAuthIndicators();

          if (!netOk) {
            const chainNames = Object.values(CHAINS).map(c => c.chainName).join(', ');
            notify('warning', 'Please switch to a supported network.');
            showAlert('Unsupported Network', `The current network is not supported. Please switch to one of: ${chainNames}`, { okText: 'Got it' });
          } else {
            // Update selected chain based on current wallet chain
            const chainEntry = Object.entries(CHAINS).find(([k, v]) => v.chainId.toLowerCase() === currentChainId);
            if (chainEntry) {
              const [chainKey] = chainEntry;
              const chainSelect = document.getElementById('chain-select');
              if (chainSelect) chainSelect.value = chainKey;
              window.selectedChain = chainKey;
              // Refresh tokens for new chain
              try { await fetchTokens(); } catch (_) { }
            }
          }
        };
        if (provider && typeof provider.on === 'function') {
          provider.on('accountsChanged', onAccountsChanged);
          provider.on('chainChanged', onChainChanged);
        }
        window._providerListeners = { provider, accountsChanged: onAccountsChanged, chainChanged: onChainChanged };
      } catch (e) { console.warn('subscribeToProvider failed', e); }
    }

    function loadSession() {
      try {
        const raw = localStorage.getItem('dex_auth_session');
        if (!raw) { window.dexAuth = { valid: false }; return window.dexAuth; }
        const session = JSON.parse(raw);
        const now = Date.now();
        const valid = !!session && now < Number(session.expires || 0);
        window.dexAuth = { ...(session || {}), valid };
        return window.dexAuth;
      } catch (_) { window.dexAuth = { valid: false }; return window.dexAuth; }
    }

    function saveSession(session) {
      try {
        localStorage.setItem('dex_auth_session', JSON.stringify(session));
        window.dexAuth = { ...(session || {}), valid: true };
      } catch (_) { }
    }

    function clearSession() {
      try { localStorage.removeItem('dex_auth_session'); } catch (_) { }
      window.dexAuth = { valid: false };
    }

    function buildSignMessage(address) {
      const ts = new Date().toISOString();
      const nonce = Math.random().toString(36).slice(2);
      const domain = 'onchain-dex-v1';
      const chain = getSelectedChain();
      const chainName = CHAINS[chain]?.chainName || 'DEX';
      return `Sign in to ${chainName}\nAddress: ${address}\nTime: ${ts}\nNonce: ${nonce}\nDomain: ${domain}`;
    }

    async function promptSignIn() {
      try {
        const { signer } = getEthers();
        const address = await signer.getAddress();
        const msg = buildSignMessage(address);
        notify('info', 'Please sign the message to complete sign-in.');
        const signature = await signer.signMessage(msg);
        const recovered = ethers.utils.verifyMessage(msg, signature);
        if (recovered?.toLowerCase() !== address?.toLowerCase()) {
          notify('error', 'Signature verification failed.');
          window.authState = { ...(window.authState || {}), signedIn: false };
          updateAuthIndicators();
          return false;
        }
        const TTL_MS = 24 * 60 * 60 * 1000; // 24 hours
        const session = {
          address,
          wallet: window.currentWalletName,
          signature,
          msg,
          signedAt: Date.now(),
          expires: Date.now() + TTL_MS
        };
        saveSession(session);
        window.authState = { ...(window.authState || {}), signedIn: true };
        updateAuthIndicators();
        notify('success', 'Signed in successfully. Features unlocked.');
        loadHistoryIfEligible();
        return true;
      } catch (e) {
        notify('error', e?.message || 'Sign-in failed.');
        window.authState = { ...(window.authState || {}), signedIn: false };
        updateAuthIndicators();
        return false;
      }
    }

    async function ensureNetwork(provider) {
      const ethProvider = provider || window.currentProvider || window.ethereum;
      if (!ethProvider) return false;
      const selectedChainKey = getSelectedChain();
      const chainConfig = CHAINS[selectedChainKey];
      try {
        const chainId = await ethProvider.request({ method: 'eth_chainId' });
        if (chainId?.toLowerCase() === chainConfig.chainId.toLowerCase()) return true;
        try {
          await ethProvider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: chainConfig.chainId }] });
          return true;
        } catch (e) {
          if (e && (e.code === 4902 || /not/i.test(String(e.message)))) {
            try {
              await ethProvider.request({
                method: 'wallet_addEthereumChain', params: [{
                  chainId: chainConfig.chainId,
                  chainName: chainConfig.chainName,
                  nativeCurrency: chainConfig.nativeCurrency,
                  rpcUrls: chainConfig.rpcUrls,
                  blockExplorerUrls: chainConfig.blockExplorerUrls
                }]
              });
              return true;
            } catch (_) { return false; }
          }
          return false;
        }
      } catch (_) { return false; }
    }

    async function requireAuthSequence() {
      try {
        const selected = localStorage.getItem('dex_last_wallet') || 'MetaMask';
        let provider = window.currentProvider || resolveProviderBySelection(selected);
        if (!provider) {
          notify('error', 'No wallet provider found.');
          return false;
        }
        // 1) Verify connection
        const accounts = await provider.request({ method: 'eth_accounts' });
        if (!accounts || accounts.length === 0) {
          notify('info', 'Please connect your wallet to continue.');
          await connectButtonHandler();
          provider = window.currentProvider;
        }
        const addr = window.currentAddress || (accounts && accounts[0]);
        if (!addr) {
          notify('error', 'Wallet connection is required.');
          window.authState = { ...(window.authState || {}), connected: false };
          updateAuthIndicators();
          return false;
        }
        window.authState = { ...(window.authState || {}), connected: true };
        updateAuthIndicators();
        // 2) Confirm network change to selected chain
        const netOk = await ensureNetwork(provider);
        window.authState = { ...(window.authState || {}), networkOk: !!netOk };
        updateAuthIndicators();
        if (!netOk) {
          const chain = getSelectedChain();
          const chainName = CHAINS[chain]?.chainName || 'selected network';
          notify('error', `Please switch to ${chainName} to proceed.`);
          return false;
        }
        // 3) Prompt sign-in if not already signed
        loadSession();
        const sessionValid = !!(window.dexAuth && window.dexAuth.valid && window.dexAuth.address?.toLowerCase() === addr?.toLowerCase());
        if (!sessionValid) {
          const ok = await promptSignIn();
          if (!ok) return false;
        } else {
          window.authState = { ...(window.authState || {}), signedIn: true };
          updateAuthIndicators();
        }
        window.authGranted = true;
        return true;
      } catch (e) {
        notify('error', e?.message || 'Authentication sequence failed.');
        return false;
      }
    }
    async function disconnectWallet() {
      try {
        const listeners = window._providerListeners || {};
        const provider = listeners.provider || window.currentProvider;
        if (provider && typeof provider.removeListener === 'function') {
          try { if (listeners.accountsChanged) provider.removeListener('accountsChanged', listeners.accountsChanged); } catch (_) { }
          try { if (listeners.chainChanged) provider.removeListener('chainChanged', listeners.chainChanged); } catch (_) { }
        }
        window._providerListeners = {};
        window.currentProvider = null;
        window.currentWalletName = null;
        window.currentAddress = null;
        setDisconnectedUI();
        notify('info', 'Disconnected wallet');
        clearSession();
      } catch (e) {
        notify('error', e?.message || 'Failed to disconnect');
      }
    }

    async function connectButtonHandler() {
      try {
        // Get selected wallet from localStorage (set when user clicks wallet option)
        const selected = localStorage.getItem('dex_last_wallet') || 'MetaMask';
        const ethProvider = resolveProviderBySelection(selected);

        if (ethProvider && typeof ethProvider.request === 'function') {
          const accounts = await ethProvider.request({ method: 'eth_requestAccounts' });
          const selectedChainKey = getSelectedChain();
          const chainConfig = CHAINS[selectedChainKey];
          try {
            await ethProvider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: chainConfig.chainId }] });
          } catch (e) {
            if (e && (e.code === 4902 || /not/i.test(String(e.message)))) {
              try {
                await ethProvider.request({
                  method: 'wallet_addEthereumChain',
                  params: [{
                    chainId: chainConfig.chainId,
                    chainName: chainConfig.chainName,
                    nativeCurrency: chainConfig.nativeCurrency,
                    rpcUrls: chainConfig.rpcUrls,
                    blockExplorerUrls: chainConfig.blockExplorerUrls
                  }]
                });
              } catch (_) { }
            }
          }
          window.currentProvider = ethProvider;
          window.currentWalletName = selected;
          window.currentAddress = Array.isArray(accounts) ? accounts[0] : null;
          window.ethereum = ethProvider; // Normalize for downstream usage for ethers
          subscribeToProvider(ethProvider);
          setConnectedUI(window.currentAddress, selected);
          notify('success', `${selected} connected`);
          try {
            localStorage.setItem('dex_last_wallet', selected);
            if (window.currentAddress) localStorage.setItem('dex_last_address', window.currentAddress);
          } catch (_) { }
          // Update indicators for network status
          const netOk = (await getChainId()) === CHAINS[getSelectedChain()].chainId.toLowerCase();
          window.authState = { ...(window.authState || {}), networkOk: !!netOk };
          updateAuthIndicators();
          if (netOk) {
            notify('info', 'Network confirmed. You can now sign in.');
          } else {
            notify('warning', `Please switch to ${CHAINS[getSelectedChain()].chainName} to proceed.`);
          }
          return;
        }
        notify('error', `${selected} wallet not installed or unavailable.`);
      } catch (e) {
        notify('error', e?.message || 'Failed to connect wallet');
      }
    }

    // Wire up manual connect button and dropdown menu
    (function wireConnectUI() {
      const bind = () => {
        const btn = document.getElementById('onboard-connect-btn');
        const menu = document.getElementById('wallet-dropdown');
        const chainSection = document.getElementById('chain-selection');
        const walletSection = document.getElementById('wallet-selection');
        const chainSelect = document.getElementById('chain-select');
        const disconnectOpt = document.getElementById('wallet-disconnect-option');
        const signBtn = document.getElementById('sign-in-btn');
        const hamburger = document.getElementById('hamburger');
        const mobileNav = document.getElementById('mobile-nav');
        const walletBackBtn = document.getElementById('wallet-back-btn');
        const selectedChainLabel = document.getElementById('selected-chain-label');

        if (!btn) { console.warn('[dex] Connect button not found'); return; }
        if (!menu) { console.warn('[dex] Wallet dropdown menu not found'); return; }

        const openMenu = () => {
          menu.classList.add('open');
          // Always show chain selection first when opening
          if (chainSection) chainSection.style.display = 'block';
          if (walletSection) walletSection.style.display = 'none';
        };
        const closeMenu = () => { menu.classList.remove('open'); };
        const isOpen = () => menu.classList.contains('open');

        // Show wallet section (step 2)
        const showWalletSection = (chainKey) => {
          if (chainSection) chainSection.style.display = 'none';
          if (walletSection) walletSection.style.display = 'block';
          if (selectedChainLabel) {
            const chainName = CHAINS[chainKey]?.chainName || chainKey;
            selectedChainLabel.textContent = `(${chainName})`;
          }
        };

        // Show chain section (step 1)
        const showChainSection = () => {
          if (chainSection) chainSection.style.display = 'block';
          if (walletSection) walletSection.style.display = 'none';
        };

        // Click connect: show menu if closed
        btn.addEventListener('click', (e) => {
          e.preventDefault();
          if (!isOpen()) {
            openMenu();
          }
        });

        // Chain option click - selects chain and shows wallet list
        menu.querySelectorAll('.chain-option').forEach(opt => {
          opt.addEventListener('click', async () => {
            const chainKey = opt.getAttribute('data-chain');
            if (!chainKey || !CHAINS[chainKey]) return;

            // Save chain to localStorage and update hidden input
            setSelectedChain(chainKey);

            // Update tokens for this chain
            try { await fetchTokens(); } catch (_) { }

            // Show wallet selection step
            showWalletSection(chainKey);
          });
        });

        // Wallet option click - connects wallet
        menu.querySelectorAll('#wallet-selection .wallet-option[data-wallet]').forEach(opt => {
          opt.addEventListener('click', async () => {
            const w = opt.getAttribute('data-wallet');
            if (!w) return;
            if (w === '__disconnect__') {
              closeMenu();
              const ok = await confirmDialog('Disconnect Wallet', 'Are you sure you want to disconnect?', { confirmText: 'Disconnect', cancelText: 'Cancel' });
              if (ok) disconnectWallet();
              return;
            }
            try { localStorage.setItem('dex_last_wallet', w); } catch (_) { }
            closeMenu();
            connectButtonHandler();
          });
        });

        // Back button - go back to chain selection
        if (walletBackBtn) {
          walletBackBtn.addEventListener('click', () => {
            showChainSection();
          });
        }

        // Click outside closes menu
        document.addEventListener('click', (evt) => {
          if (!menu.contains(evt.target) && evt.target !== btn) {
            closeMenu();
          }
        });
        // Sign-in button
        if (signBtn) {
          signBtn.addEventListener('click', async () => {
            const ok = await promptSignIn();
            if (ok) window.authGranted = true;
          });
        }

        // Hamburger toggle
        if (hamburger && mobileNav) {
          const toggleMenu = (e) => {
            if (e) e.preventDefault();
            // mobileNav.style.display = "inline";
            const open = mobileNav.classList.toggle('open');
            hamburger.classList.toggle('active', open);
            mobileNav.setAttribute('style', open ? 'display: inline;' : 'display: none;');
            hamburger.setAttribute('aria-expanded', open ? 'true' : 'false');
            hamburger.setAttribute('aria-8888888888888888label', open ? 'Close menu' : 'Open menu');
          };
          hamburger.addEventListener('click', toggleMenu);
          hamburger.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter' || ev.key === ' ') {
              ev.preventDefault();
              toggleMenu();
            }
          });
          // Close mobile nav on outside click
          document.addEventListener('click', (evt) => {
            if (!mobileNav.contains(evt.target) && evt.target !== hamburger && !hamburger.contains(evt.target)) {
              mobileNav.classList.remove('open');
              mobileNav.style.display = "none";
              hamburger.setAttribute('aria-expanded', 'false');
              hamburger.classList.remove('active');
              hamburger.setAttribute('aria-label', 'Open menu');
            }
          });
        }

        // Initialize UI and attempt auto-reconnect
        setDisconnectedUI();
        autoReconnect();
        // Adjust wallet button display on resize (mobile vs desktop)
        window.addEventListener('resize', () => {
          if (window.authState && window.authState.connected && window.currentAddress && window.currentWalletName) {
            setConnectedUI(window.currentAddress, window.currentWalletName);
          }
        });
        console.info('[dex] Connect UI wired');
      };
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', bind);
      } else {
        bind();
      }
    })();

    async function autoReconnect() {
      try {
        const last = localStorage.getItem('dex_last_wallet');
        if (!last) return;
        const provider = resolveProviderBySelection(last);
        if (!provider) return;
        const accounts = await provider.request({ method: 'eth_accounts' });
        if (accounts && accounts.length > 0) {
          window.currentProvider = provider;
          window.currentWalletName = last;
          window.currentAddress = accounts[0];
          window.ethereum = provider;
          subscribeToProvider(provider);

          // Detect wallet's current chain and sync with it
          const currentChainId = await provider.request({ method: 'eth_chainId' });
          const chainEntry = Object.entries(CHAINS).find(([k, v]) => v.chainId.toLowerCase() === (currentChainId || '').toLowerCase());
          if (chainEntry) {
            const [chainKey] = chainEntry;
            setSelectedChain(chainKey);
            // Refresh tokens for this chain
            try { await fetchTokens(); } catch (_) { }
          }

          await setConnectedUI(window.currentAddress, last);

          // Check if on a supported network
          const supportedChainIds = Object.values(CHAINS).map(c => c.chainId.toLowerCase());
          const netOk = supportedChainIds.includes((currentChainId || '').toLowerCase());
          window.authState = { ...(window.authState || {}), networkOk: !!netOk };
          updateAuthIndicators();

          loadSession();
          const sessionValid = !!(window.dexAuth && window.dexAuth.valid && window.dexAuth.address?.toLowerCase() === window.currentAddress?.toLowerCase());
          if (sessionValid && netOk) {
            window.authState = { ...(window.authState || {}), signedIn: true };
            updateAuthIndicators();
            window.authGranted = true;
            notify('success', 'Reconnected to wallet and restored session.');
            loadHistoryIfEligible();
          } else {
            notify('info', 'Wallet reconnected. Please sign in to unlock features.');
          }
        }
      } catch (e) { console.warn('autoReconnect failed', e); }
    }

    // MetaMask handles status via initMetaMaskHeader

    // Generate random reference IDs
    const randRef = () => 'REF-' + Math.random().toString(36).slice(2, 10).toUpperCase();
    const refAir = $('#airtime-ref'); if (refAir) refAir.value = randRef();
    const refData = $('#data-ref'); if (refData) refData.value = randRef();

    // Fetch network providers
    async function fetchNetworks() {
      try {
        const res = await fetch(`${apiBase}/access.php?action=getNetworks`);
        const data = await res.json();
        const netsRaw = data.networks || data.data || [];
        const nets = netsRaw.filter(n => (n.status || 'On') === 'On');
        if (!nets.length) throw new Error('No networks available');
        const networkOptions = nets.map(n =>
          `<option value="${n.id}">${n.name || n.network}</option>`
        ).join('');

        const airNet = $('#airtime-network');
        if (airNet) {
          airNet.innerHTML = networkOptions;
          airNet.value = nets[0]?.id || '';
        }

        const dataNet = $('#data-network');
        if (dataNet) {
          dataNet.innerHTML = networkOptions;
          dataNet.value = nets[0]?.id || '';
        }
      } catch (e) {
        console.warn('Networks fetch failed', e);
        showStatus($('#airtime-status'), 'Failed to load networks', false);
      }
    }

    // Fetch available tokens for selection
    async function fetchTokens() {
      try {
        const chain = getSelectedChain();
        const res = await fetch(`${apiBase}/access.php?action=getTokens&chain=${chain}`);
        const data = await res.json();
        const tokens = data.tokens || data.data || [];
        const sel = document.getElementById('airtime-token');
        const sel2 = document.getElementById('data-token');
        if (!sel) return;
        if (!tokens.length) { sel.innerHTML = '<option value="">No tokens available</option>'; return; }
        sel.innerHTML = tokens.map(t => `<option value="${t.token_contract}" data-decimals="${t.token_decimals}">${t.token_name}</option>`).join('');
        if (sel2) sel2.innerHTML = sel.innerHTML;
        // Default select first
        sel.value = tokens[0].token_contract;
        if (sel2) sel2.value = tokens[0].token_contract;
        window.availableTokens = tokens;
        window.tokenByName = {}; window.tokenByContract = {};
        tokens.forEach(t => { window.tokenByName[(t.token_name || '').toUpperCase()] = t; window.tokenByContract[(t.token_contract || '').toLowerCase()] = t; });
      } catch (e) { console.warn('Tokens fetch failed', e); }
    }

    // Chain select listener
    document.getElementById('chain-select')?.addEventListener('change', async () => {
      const provider = window.currentProvider;
      if (provider) {
        await ensureNetwork(provider);
      }
      await fetchTokens();
      if (window.authState?.connected && window.currentAddress) {
        loadHistoryIfEligible();
      }
    });

    async function addTokenToWallet(selectId) {
      try {
        const sel = document.getElementById(selectId);
        if (!sel || !sel.value) return;
        const address = sel.value;
        const token = window.availableTokens ? window.availableTokens.find(t => t.token_contract.toLowerCase() === address.toLowerCase()) : null;

        if (!token) {
          notify('error', 'Token details not found');
          return;
        }

        if (!window.ethereum) {
          notify('error', 'No wallet provider found');
          return;
        }

        await window.ethereum.request({
          method: 'wallet_watchAsset',
          params: {
            type: 'ERC20',
            options: {
              address: token.token_contract,
              symbol: token.token_name,
              decimals: Number(token.token_decimals),
              image: token.token_image || token.image || '',
            },
          },
        });
        notify('success', `Request to add ${token.token_name} sent`);
      } catch (error) {
        console.error(error);
        notify('error', 'Failed to add token to wallet');
      }
    }

    // Fetch data plans based on selected network
    async function fetchDataPlans() {
      try {
        const netEl = $('#data-network');
        if (!netEl) return;
        const network = netEl.value;
        if (!network) return;
        const res = await fetch(`${apiBase}/access.php?action=getDataPlans&network=${encodeURIComponent(network)}`);
        const data = await res.json();
        const plans = data.plans || data.data || [];
        const planEl = $('#data-plan');
        if (!planEl) return;
        if (!plans.length) { planEl.innerHTML = ''; return; }
        planEl.innerHTML = plans.map(p => {
          const labelParts = [p.name, p.type, p.day ? `${p.day}d` : ''].filter(Boolean);
          return `<option value="${p.id || p.plan_id}">${labelParts.join(' ')}</option>`;
        }).join('');
        // Default select first plan
        const firstId = plans[0]?.id || plans[0]?.plan_id || '';
        if (firstId) planEl.value = firstId;
      } catch (e) {
        console.warn('Plans fetch failed', e);
        showStatus($('#data-status'), 'Failed to load data plans', false);
      }
    }

    // Fetch site settings for  address
    async function fetchSiteSettings() {
      try {
        const res = await fetch(`${apiBase}/access.php?action=getSiteSettings`);
        const data = await res.json();
        const siteaddr = data.walletaddress || data.tonaddress || data.siteaddress || '';

        if (siteaddr) {
          const at = $('#airtime-target'); if (at) at.value = siteaddr;
          const dt = $('#data-target'); if (dt) dt.value = siteaddr;
        }
      } catch (e) {
        console.warn('Site settings fetch failed', e);
      }
    }

    // Set up event listeners
    const dn = $('#data-network');
    if (dn) dn.addEventListener('change', fetchDataPlans);

    // Initialize data and tabs
    fetchNetworks().then(fetchDataPlans).then(fetchSiteSettings).then(fetchTokens);
    initTabs();

    // Cache for CNGN tokens per chain
    const cngnCache = {};
    const CNGN_DECIMALS = 6;

    // Fetch CNGN contract from database for a specific chain
    async function getCngnForChain(chain) {
      // Check cache first
      if (cngnCache[chain]) return cngnCache[chain];

      try {
        const res = await fetch(`${apiBase}/access.php?action=getCngnToken&chain=${chain}`);
        const data = await res.json();
        if (data.status === 'success' && data.token) {
          cngnCache[chain] = {
            contract: data.token.token_contract,
            decimals: Number(data.token.token_decimals) || 6
          };
          return cngnCache[chain];
        }
      } catch (e) {
        console.warn('Failed to fetch CNGN for chain:', chain, e);
      }

      // Fallback for AssetChain
      if (chain === 'assetchain') {
        return { contract: '0x7923C0f6FA3d1BA6EAFCAedAaD93e737Fd22FC4F', decimals: 6 };
      }
      return null;
    }

    // Calculate CNGN amount in wei for airtime
    async function calcWeiFromNaira(naira) {
      try {
        const ngnInt = Math.floor(Number(naira || 0));
        if (!ngnInt || ngnInt <= 0) return '';

        const chain = getSelectedChain();
        const sel = document.getElementById('airtime-token');
        const selectedContract = sel?.value || '';
        const selectedName = sel?.selectedOptions[0]?.text || '';
        const selectedDecimals = Number(sel?.selectedOptions[0]?.getAttribute('data-decimals') || 18);

        // Get CNGN contract for this chain from database
        let priceChain = chain;

        // For Arbitrum, use Base CNGN since not available on Arbitrum
        if (chain === 'arbitrum') {
          priceChain = 'base';
        }

        const cngnData = await getCngnForChain(priceChain);
        if (!cngnData || !cngnData.contract) {
          console.warn('CNGN not found for chain:', priceChain);
          return '';
        }
        const cngnContract = cngnData.contract;
        const cngnDecimals = cngnData.decimals || CNGN_DECIMALS;

        // Calculate CNGN amount in wei
        const cngnWei = ethers.BigNumber.from(ngnInt.toString()).mul(ethers.BigNumber.from('1' + '0'.repeat(cngnDecimals)));

        // If selected token is CNGN, return cngnWei
        if ((selectedName || '').toUpperCase() === 'CNGN' || selectedContract.toLowerCase() === cngnContract.toLowerCase()) {
          return cngnWei.toString();
        }

        // For AssetChain, use liquidity pool API
        if (chain === 'assetchain') {
          const tokenOut = selectedContract;
          const tokenIn = cngnContract;
          const url = `https://liquidity-pool-api.assetchain.org/swaps/routes?tokenIn=${encodeURIComponent(tokenIn)}&tokenOut=${encodeURIComponent(tokenOut)}&amountIn=${cngnWei.toString()}&maxHops=2&includeAlternatives=true&slippageTolerance=1&includeLowLiquidityPools=true`;
          try {
            const resp = await fetch(url);
            const data = await resp.json();
            const routes = data.routes || [];
            if (!routes.length || !routes[0].amountOut) return '';
            return String(routes[0].amountOut);
          } catch (_) { return ''; }
        }

        // For BSC, Base, Arbitrum - use Moralis API to get token prices
        try {
          // Get CNGN price in USD
          const cngnPriceRes = await fetch(`${apiBase}/access.php?action=getTokenPrice&address=${cngnContract}&chain=${priceChain}`);
          const cngnPriceData = await cngnPriceRes.json();
          const cngnPriceUsd = cngnPriceData?.price || cngnPriceData?.usdPrice || cngnPriceData?.priceNgn / 1600 || 0.000625;

          // Get selected token price in USD
          let addr = selectedContract;
          if (!addr || !addr.startsWith('0x')) addr = 'native';

          const tokenPriceRes = await fetch(`${apiBase}/access.php?action=getTokenPrice&address=${addr}&chain=${chain}`);
          const tokenPriceData = await tokenPriceRes.json();
          const tokenPriceUsd = tokenPriceData?.price || tokenPriceData?.usdPrice || 0;

          if (!tokenPriceUsd || tokenPriceUsd <= 0) {
            console.warn('Could not get token price for', selectedName, 'at address', addr);
            return '';
          }

          // Calculate: CNGN value in USD / Token price in USD = amount of tokens needed
          const cngnValueUsd = ngnInt * cngnPriceUsd;
          const tokenAmount = cngnValueUsd / tokenPriceUsd;

          // Convert to wei based on token decimals
          const tokenWei = ethers.utils.parseUnits(tokenAmount.toFixed(selectedDecimals), selectedDecimals);
          return tokenWei.toString();
        } catch (e) {
          console.warn('Moralis price calculation failed:', e);
          return '';
        }
      } catch (e) {
        console.warn('calcWeiFromNaira error:', e);
        return '';
      }
    }

    async function calcWeiFromNairaBySelector(selectorId, naira) {
      try {
        const ngnInt = Math.floor(Number(naira || 0));
        if (!ngnInt || ngnInt <= 0) return '';

        const chain = getSelectedChain();
        const sel = document.getElementById(selectorId);
        const selectedContract = sel?.value || '';
        const selectedName = sel?.selectedOptions[0]?.text || '';
        const selectedDecimals = Number(sel?.selectedOptions[0]?.getAttribute('data-decimals') || 18);

        // Get CNGN contract for this chain from database
        let priceChain = chain;

        // For Arbitrum, use Base CNGN since not available on Arbitrum
        if (chain === 'arbitrum') {
          priceChain = 'base';
        }

        const cngnData = await getCngnForChain(priceChain);
        if (!cngnData || !cngnData.contract) {
          console.warn('CNGN not found for chain:', priceChain);
          return '';
        }
        const cngnContract = cngnData.contract;
        const cngnDecimals = cngnData.decimals || CNGN_DECIMALS;

        // Calculate CNGN amount in wei
        const cngnWei = ethers.BigNumber.from(ngnInt.toString()).mul(ethers.BigNumber.from('1' + '0'.repeat(cngnDecimals)));

        // If selected token is CNGN, return cngnWei
        if ((selectedName || '').toUpperCase() === 'CNGN' || selectedContract.toLowerCase() === cngnContract.toLowerCase()) {
          return cngnWei.toString();
        }

        // For AssetChain, use liquidity pool API
        if (chain === 'assetchain') {
          const tokenOut = selectedContract;
          const tokenIn = cngnContract;
          const url = `https://liquidity-pool-api.assetchain.org/swaps/routes?tokenIn=${encodeURIComponent(tokenIn)}&tokenOut=${encodeURIComponent(tokenOut)}&amountIn=${cngnWei.toString()}&maxHops=2&includeAlternatives=true&slippageTolerance=1&includeLowLiquidityPools=true`;
          try {
            const resp = await fetch(url);
            const data = await resp.json();
            const routes = data.routes || [];
            if (!routes.length || !routes[0].amountOut) return '';
            return String(routes[0].amountOut);
          } catch (_) { return ''; }
        }

        // For BSC, Base, Arbitrum - use Moralis API to get token prices
        try {
          // Get CNGN price in USD
          const cngnPriceRes = await fetch(`${apiBase}/access.php?action=getTokenPrice&address=${cngnContract}&chain=${priceChain}`);
          const cngnPriceData = await cngnPriceRes.json();
          const cngnPriceUsd = cngnPriceData?.price || cngnPriceData?.usdPrice || cngnPriceData?.priceNgn / 1600 || 0.000625;

          // Get selected token price in USD
          let addr = selectedContract;
          if (!addr || !addr.startsWith('0x')) addr = 'native';

          const tokenPriceRes = await fetch(`${apiBase}/access.php?action=getTokenPrice&address=${addr}&chain=${chain}`);
          const tokenPriceData = await tokenPriceRes.json();
          const tokenPriceUsd = tokenPriceData?.price || tokenPriceData?.usdPrice || 0;

          if (!tokenPriceUsd || tokenPriceUsd <= 0) {
            console.warn('Could not get token price for', selectedName, 'at address', addr);
            return '';
          }

          // Calculate token amount needed
          const cngnValueUsd = ngnInt * cngnPriceUsd;
          const tokenAmount = cngnValueUsd / tokenPriceUsd;

          // Convert to wei
          const tokenWei = ethers.utils.parseUnits(tokenAmount.toFixed(selectedDecimals), selectedDecimals);
          return tokenWei.toString();
        } catch (e) {
          console.warn('Moralis price calculation failed:', e);
          return '';
        }
      } catch (e) { return ''; }
    }

    // History styles (inline minimal)
    const styleHist = document.createElement('style');
    styleHist.textContent = `
      .history-list { display: grid; grid-template-columns: 1fr; gap: 8px; }
      .history-item { border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 10px; display: grid; gap: 6px; cursor: pointer; transition: var(--transition); }
      .history-item:hover { background: rgba(255,255,255,0.06); }
      .history-row { display: flex; justify-content: space-between; align-items: center; }
      .history-hash a, .history-hash span { font-family: monospace; font-size: 12px; white-space: nowrap; }
      .history-meta { color: var(--gray); font-size: 12px; }
      .history-amount { font-weight: 600; }
      .history-type { font-size: 12px; }
      .history-status { font-size: 12px; font-weight: 600; }
      .history-status.success { color: #00D897; }
      .history-status.failed { color: #FF4757; }
      .history-status.pending { color: #FFB547; }
      .history-pagination { display:flex; align-items:center; gap:10px; justify-content:flex-end; margin-top:12px; }
      .history-controls { margin: 10px 0; }
      @media (min-width: 768px) { .history-item { grid-template-columns: 1.4fr 1fr 1fr; } }
    `;
    document.head.appendChild(styleHist);

    const styleModal = document.createElement('style');
    styleModal.textContent = `
      .tx-modal { position: fixed; inset: 0; z-index: 1300; display:flex; align-items:center; justify-content:center; padding: 20px; }
      .tx-backdrop { position: absolute; inset: 0; background: rgba(0,0,0,0.6); }
      .tx-content { position: relative; width: 100%; max-width: 760px; max-height: 80vh; overflow: hidden; background: var(--card-bg); border: 1px solid rgba(255,255,255,0.15); border-radius: 12px; box-shadow: 0 20px 60px rgba(0,0,0,0.5); }
      .tx-header { display:flex; align-items:center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid rgba(255,255,255,0.08); }
      .tx-body { max-height: 60vh; overflow: auto; padding: 14px 16px; }
      .tx-grid { display: grid; grid-template-columns: 1fr; gap: 8px 16px; }
      @media (min-width: 768px) { .tx-grid { grid-template-columns: 1fr 1fr; } }
      .tx-kv { display: flex; gap: 8px; }
      .tx-kv .k { color: var(--gray); min-width: 140px; }
      .tx-kv .v { font-family: monospace; font-size: 13px; word-break: break-all; }
    `;
    document.head.appendChild(styleModal);

    function statusLabel(s) {
      const n = Number(s);
      if (n === 0 || n === 9) return { text: 'confirmed', cls: 'success' };
      if (n === 1) return { text: 'failed', cls: 'failed' };
      return { text: 'pending', cls: 'pending' };
    }
    function inferTxType(item, userAddr) {
      if (item.servicename === 'Refund') return 'Refund';
      if (item.servicename === 'Airtime') return 'Airtime';
      if (item.servicename === 'Data') return 'Data';
      if (item.servicename === 'Wallet Credit') return 'Deposit';
      const from = (item.senderaddress || '').toLowerCase();
      const to = (item.targetaddress || '').toLowerCase();
      const u = (userAddr || '').toLowerCase();
      if (from === u && to !== u) return 'deposit';
      if (to === u && from !== u) return 'withdrawal';
      return 'other';
    }
    function truncateCenter(text, start = 5, end = 5) {
      const t = String(text || '');
      if (t.length <= start + end) return t;
      return t.slice(0, start) + 'â€¦' + t.slice(-end);
    }
    function pad2(n) { return String(n).padStart(2, '0'); }
    function formatDateTime(s) {
      try { const d = new Date(s); if (isNaN(d.getTime())) return s; return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())} ${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}`; }
      catch (_) { return s; }
    }
    async function renderHistoryItems(items, userAddr, chainIdHex) {
      const list = document.getElementById('history-list');
      if (!list) return;
      list.innerHTML = '';
      if (!items || items.length === 0) {
        list.innerHTML = '<div class="history-item">No transactions found for this address.</div>';
        return;
      }

      const provider = window.currentProvider || window.ethereum;
      const currentChainId = provider ? await provider.request({ method: 'eth_chainId' }) : ASSETCHAIN_ID_HEX;

      for (const item of items) {
        const row = document.createElement('div'); row.className = 'history-item';
        row.setAttribute('tabindex', '0');
        const top = document.createElement('div'); top.className = 'history-row';
        const hashEl = document.createElement('div'); hashEl.className = 'history-hash';
        const h = item.txhash || '';
        const url = h ? buildExplorerUrl('tx', chainIdHex || currentChainId || ASSETCHAIN_ID_HEX, h) : null;
        const displayHash = h ? truncateCenter(h, 7, 5) : 'â€”';
        if (url) { const a = document.createElement('a'); a.href = url; a.target = '_blank'; a.rel = 'noopener noreferrer'; a.textContent = displayHash; a.title = h; hashEl.appendChild(a); }
        else { const span = document.createElement('span'); span.textContent = displayHash; span.title = h; hashEl.appendChild(span); }
        const meta = document.createElement('div'); meta.className = 'history-meta'; meta.textContent = formatDateTime(item.date || '');
        top.appendChild(hashEl); top.appendChild(meta);

        const mid = document.createElement('div'); mid.className = 'history-row';
        const type = document.createElement('div'); type.className = 'history-type'; type.textContent = inferTxType(item, userAddr);
        const pair = document.createElement('div'); pair.className = 'history-meta'; pair.textContent = item.token_name || 'â€”';
        mid.appendChild(type); mid.appendChild(pair);

        const bot = document.createElement('div'); bot.className = 'history-row';
        const amount = document.createElement('div'); amount.className = 'history-amount'; amount.textContent = `N${item.amount || '0.00'}`;
        const st = statusLabel(item.status);
        let statusText = st.text;
        let statusClass = st.cls;
        if (item.servicename === 'Refund' && (Number(item.status) === 0 || Number(item.status) === 9)) {
          statusText = 'refunded';
          statusClass = 'success';
        }
        if (item.servicename === 'Refund' && Number(item.status) === 1) {
          statusText = 'refund failed';
          statusClass = 'failed';
        }
        const statusEl = document.createElement('div'); statusEl.className = 'history-status ' + statusClass; statusEl.textContent = statusText;
        bot.appendChild(amount); bot.appendChild(statusEl);

        row.appendChild(top); row.appendChild(mid); row.appendChild(bot);
        const onOpen = () => { openTxModal(item); };
        row.addEventListener('click', onOpen);
        row.addEventListener('keydown', (ev) => { if (ev.key === 'Enter' || ev.key === ' ') { ev.preventDefault(); onOpen(); } });
        list.appendChild(row);
      }
    }
    async function fetchGasFee(hash) {
      try {
        const chain = getSelectedChain();
        const conf = CHAINS[chain];
        let provider;
        if (window.ethereum) {
          provider = new ethers.providers.Web3Provider(window.ethereum, 'any');
        } else {
          const rpc = conf?.rpcUrls?.[0] || 'https://mainnet-rpc.assetchain.org/';
          provider = new ethers.providers.JsonRpcProvider(rpc);
        }
        const receipt = await provider.getTransactionReceipt(hash);
        if (!receipt) return 'N/A';
        return computeGasFee(receipt);
      } catch (_) { return 'N/A'; }
    }
    function openTxModal(item) {
      const chain = getSelectedChain() || 'assetchain';
      const conf = CHAINS[chain];
      const chainIdHex = window.authState?.networkOk ? (conf?.chainId || ASSETCHAIN_ID_HEX) : (conf?.chainId || ASSETCHAIN_ID_HEX);
      const st = statusLabel(item.status);
      const parsedProvider = parseProviderFromDescription(item.servicedesc || item.servicedescription || '');
      const parsedPhone = parsePhoneFromDescription(item.servicedesc || item.servicedescription || '');
      const model = {
        status: st.text === 'confirmed' ? 'success' : (st.text === 'failed' ? 'failed' : 'pending'),
        backendStatus: 'HISTORY',
        timestamp: item.date,
        hash: item.txhash,
        reference: item.txref || '',
        from: item.senderaddress,
        to: item.targetaddress,
        amountDisplay: item.token_amount + ' ' + (item.token_name || 'CNGN'),
        tokenAmount: item.token_amount,
        gasFee: 'Loading...',
        networkName: conf?.chainName || 'Assetchain Mainnet',
        chainId: chainIdHex,
        chainIdHex,
        symbol: item.token_name || 'CNGN',
        decimals: Number(item.token_decimals) || 6,
        message: null,
        service: (item.servicename || item.service || (item.data_plan ? 'Data Purchase' : 'Airtime Purchase')),
        purchaseValue: (item.data_plan ? ((item.plan_label || item.plan_name || item.data_plan) + ' Data') : ((item.amount ? `${item.amount}N` : `N${item.amount || '0.00'} Airtime`))),
        providerDisplay: parsedProvider || 'â€”',
        recipientPhone: parsedPhone || 'N/A',
        description: item.servicedesc || item.servicedescription || ''
      };
      const card = openReceiptModal(model);
      (async () => {
        try {
          const verified = await verifyProviderName(parsedProvider);
          const display = verified || 'Unknown';
          const pv = card.querySelector('.kv-provider'); if (pv) pv.textContent = display;
        } catch (_) { const pv = card.querySelector('.kv-provider'); if (pv) pv.textContent = parsedProvider || 'Unknown'; }
      })();
    }
    async function fetchWalletHistory(address, page = 0, perPage = 10) {
      const chain = getSelectedChain();
      const url = `${apiBase}/access.php?action=getWalletTransactions&address=${encodeURIComponent(address)}&page=${page}&limit=${perPage}&chain=${chain}`;
      const res = await fetch(url);
      return res.json();
    }
    async function loadHistoryIfEligible() {
      const card = document.getElementById('history-card');
      if (!card) return;

      try {
        const state = window.authState || {};
        const address = window.currentAddress;

        // Always show the card when this function is called (e.g. tab click or connection)
        card.style.display = 'block';

        // If not connected, show message and return
        if (!state.connected || !address) {
          console.warn('[dex] History skipped: not connected or no address');
          const list = document.getElementById('history-list');
          if (list) list.innerHTML = '<div class="history-item" style="text-align:center; padding:20px; color: var(--gray);">Please connect your wallet to view transaction history.</div>';
          const status = document.getElementById('history-status');
          if (status) status.textContent = '';
          return;
        }

        const status = document.getElementById('history-status');
        const pageEl = document.getElementById('history-page');
        const prev = document.getElementById('history-prev');
        const next = document.getElementById('history-next');

        if (status) status.textContent = 'Loading history...';
        const chain = getSelectedChain();
        const conf = CHAINS[chain];
        let network = conf?.chainId || ASSETCHAIN_ID_HEX;
        try {
          const cid = await getChainId();
          if (cid) network = cid;
        } catch (e) {
          console.warn('Failed to get chainId, using default', e);
        }
        let page = 0; const perPage = 10;
        let lastData = null;
        const sortSel = document.getElementById('history-sort');
        const filterSel = document.getElementById('history-filter');
        const sortItems = (items) => {
          const v = sortSel?.value || 'date_desc';
          const cp = [...items];
          if (v === 'date_asc') cp.sort((a, b) => new Date(a.date) - new Date(b.date));
          else if (v === 'date_desc') cp.sort((a, b) => new Date(b.date) - new Date(a.date));
          else if (v === 'amount_asc') cp.sort((a, b) => Number(a.amount) - Number(b.amount));
          else if (v === 'amount_desc') cp.sort((a, b) => Number(b.amount) - Number(a.amount));
          else if (v === 'status') cp.sort((a, b) => String(a.status).localeCompare(String(b.status)));
          return cp;
        };
        const filterItems = (items) => {
          const v = filterSel?.value || 'all';
          if (v === 'all') return items;
          if (v === 'refunded') return items.filter(i => i.servicename === 'Refund');
          return items.filter(i => {
            const s = statusLabel(i.status).text;
            return s === v;
          });
        };
        const update = async () => {
          status.textContent = 'Loading history...';
          try {
            const data = await fetchWalletHistory(address, page, perPage);
            if (data.status !== 'success') { status.textContent = data.msg || 'Failed to load history'; return; }
            status.textContent = '';
            lastData = data.items || [];
            const filtered = filterItems(lastData);
            const sorted = sortItems(filtered);
            renderHistoryItems(sorted, address, network);
            const pages = Number(data.pages || 0);
            pageEl.textContent = pages ? `Page ${Number(data.page || 0) + 1} of ${pages}` : '';
            prev.disabled = page <= 0; next.disabled = !pages || (page + 1) >= pages;
          } catch (err) {
            status.textContent = 'Error fetching history';
            console.error(err);
          }
        };
        prev.onclick = async () => { if (page > 0) { page--; await update(); } };
        next.onclick = async () => { page++; await update(); };
        if (sortSel) sortSel.addEventListener('change', update);
        if (filterSel) filterSel.addEventListener('change', update);
        const reloadBtn = document.getElementById('history-reload');
        if (reloadBtn) {
          reloadBtn.onclick = async () => {
            page = 0;
            await update();
          };
        }
        await update();
      } catch (e) {
        const status = document.getElementById('history-status');
        if (status) status.textContent = e?.message || 'Error loading history';
      }
    }
    // Explorer mapping and utilities
    const ExplorerMap = {
      '0xa5b4': { base: 'https://scan.assetchain.org', paths: { tx: (h) => `/tx/${h}`, address: (a) => `/address/${a}` } },
      '0x2105': { base: 'https://basescan.org', paths: { tx: (h) => `/tx/${h}`, address: (a) => `/address/${a}` } },
      '0x38': { base: 'https://bscscan.com', paths: { tx: (h) => `/tx/${h}`, address: (a) => `/address/${a}` } }
    };
    // Network provider numeric code â†’ name mapping
    // This maps database numeric codes to human-readable provider names
    const ProviderCodeMap = { 1: 'MTN', 2: 'GLO', 3: '9MOBILE', 4: 'AIRTEL' };
    function isHexTx(hash) { return /^0x[a-fA-F0-9]{64}$/.test(String(hash || '')); }
    function isHexAddress(addr) { return /^0x[a-fA-F0-9]{40}$/.test(String(addr || '')); }
    function buildExplorerUrl(kind, chainIdHex, value) {
      const map = ExplorerMap[(chainIdHex || '').toLowerCase()];
      if (!map) return null;
      if (kind === 'tx' && isHexTx(value)) return map.base + map.paths.tx(value);
      if (kind === 'address' && isHexAddress(value)) return map.base + map.paths.address(value);
      return null;
    }

    // Validation helpers for provider code and phone number
    function validateNetworkCode(code) {
      const n = Number(code);
      return Number.isInteger(n) && n >= 1 && n <= 4;
    }
    function validatePhoneNumber(phone) {
      const s = String(phone || '').trim();
      if (!s) return false;
      // Accept Nigerian formats: 11 digits starting with 0, or +234 followed by 10 digits, or generic 10â€“14 digits
      const ngLocal = /^0\d{10}$/;
      const ngIntl = /^\+234\d{10}$/;
      const generic = /^\+?\d{10,14}$/;
      return ngLocal.test(s) || ngIntl.test(s) || generic.test(s);
    }
    // Resolve provider name and phone from database-backed selections
    // Reads the selected network ID, fetches networks to resolve the numeric code â†’ name, and validates the phone
    async function resolveProviderDisplay(service) {
      try {
        const isAirtime = service === 'airtime';
        const selId = isAirtime ? $('#airtime-network').value : $('#data-network').value;
        const phone = isAirtime ? $('#airtime-phone').value : $('#data-phone').value;
        let providerName = 'Unknown';
        let codeResolved = null;
        if (selId) {
          const res = await fetch(`${apiBase}/access.php?action=getNetworks`);

          const json = await res.json();
          if (json && Array.isArray(json.items || json.data)) {
            const items = json.items || json.data;
            const found = items.find(n => String(n.id) === String(selId));
            if (found) {
              const numericCode = Number(found.code || found.nId || found.code_id);
              codeResolved = numericCode;
              if (validateNetworkCode(numericCode)) providerName = ProviderCodeMap[numericCode];
            }
          }
        }
        const validPhone = validatePhoneNumber(phone) ? phone : 'Invalid phone';
        if (!validateNetworkCode(codeResolved)) providerName = 'Unknown';
        return providerName;
      } catch (_) {
        const phone = (service === 'airtime' ? $('#airtime-phone').value : $('#data-phone').value) || '';
        const validPhone = validatePhoneNumber(phone) ? phone : 'Invalid phone';
        return 'Unknown';
      }
    }

    // Formatting helpers
    function formatTokenAmount(weiStr, decimals, symbol) {
      try {
        // Special rounding for USDT: 3 decimal places, standard rounding
        if (symbol && typeof symbol === 'string' && symbol.toUpperCase().includes('USDT')) {
          const val = ethers.utils.formatUnits(weiStr, decimals);
          const parts = val.split('.');
          let whole = parts[0];
          let frac = parts[1] || '';

          // Ensure we have enough digits to round
          while (frac.length < 4) frac += '0';

          const first3 = frac.substring(0, 3);
          const fourth = frac[3];

          let roundedFrac = parseInt(first3, 10);
          if (parseInt(fourth, 10) >= 5) {
            roundedFrac += 1;
          }

          // Handle carry over (e.g. 0.999 -> 1.000)
          if (roundedFrac >= 1000) {
            whole = ethers.BigNumber.from(whole).add(1).toString();
            roundedFrac = 0;
          }

          const roundedFracStr = String(roundedFrac).padStart(3, '0');
          return `${whole}.${roundedFracStr} ${symbol}`;
        }

        const wei = ethers.BigNumber.from(String(weiStr));
        const scale = ethers.BigNumber.from('1' + '0'.repeat(Number(decimals || 0)));
        const whole = wei.div(scale).toString();
        const frac = wei.mod(scale).toString().padStart(Number(decimals || 0), '0').replace(/0+$/, '');
        return frac ? `${whole}.${frac} ${symbol || ''}`.trim() : `${whole} ${symbol || ''}`.trim();
      } catch (_) { return `${weiStr} ${symbol || ''}`.trim(); }
    }
    function computeGasFee(receipt, priceUnit = 'ASET') {
      try {
        const gasUsed = receipt.gasUsed || receipt.gas || ethers.BigNumber.from(0);
        const gasPrice = receipt.effectiveGasPrice || receipt.gasPrice || ethers.BigNumber.from(0);
        const feeWei = gasUsed.mul(gasPrice);
        const fee = ethers.utils.formatEther(feeWei);
        return `${fee} ${priceUnit}`;
      } catch (_) { return `0 ${priceUnit}`; }
    }

    // Provider parsing and verification
    function parseProviderFromDescription(desc) {
      const s = String(desc || '');
      const m = /^\s*([A-Za-z0-9]+)\s+Airtime\b/i.exec(s);
      if (m && m[1]) return String(m[1]).toUpperCase();
      const m2 = /(MTN|GLO|9MOBILE|AIRTEL)/i.exec(s);
      if (m2 && m2[1]) return String(m2[1]).toUpperCase();
      return null;
    }
    function parsePhoneFromDescription(desc) {
      const s = String(desc || '');
      const m = /for\s+phone\s+number\s+(\d{11})/i.exec(s);
      if (m && m[1]) {
        const p = String(m[1]);
        return /^0\d{10}$/.test(p) ? p : null;
      }
      return null;
    }
    let __networksCache = null;
    async function fetchNetworksCached() {
      if (__networksCache) return __networksCache;
      try {
        const res = await fetch(`${apiBase}/access.php?action=getNetworks`);
        const json = await res.json();
        const items = json.items || json.data || [];
        __networksCache = items;
        return items;
      } catch (_) { __networksCache = []; return []; }
    }
    async function verifyProviderName(name) {
      if (!name) return null;
      const items = await fetchNetworksCached();
      const up = String(name).toUpperCase();
      const hit = items.find(n => String(n.network || n.name).toUpperCase() === up);
      return hit ? up : null;
    }

    // Receipt rendering
    function renderReceipt(model) {
      const wrap = document.getElementById('tx-receipts');
      if (!wrap) return null;
      const card = document.createElement('div');
      card.className = 'receipt-card';
      const header = document.createElement('div'); header.className = 'receipt-header';
      const title = document.createElement('div'); title.className = 'receipt-title';
      const tIcon = document.createElement('span');
      const isSuccess = model.status === 'success'; const isFailed = model.status === 'failed';
      tIcon.innerHTML = `<i class="fas ${isSuccess ? 'fa-check-circle' : (isFailed ? 'fa-exclamation-circle' : 'fa-hourglass-half')}"></i>`;
      const tText = document.createElement('span'); tText.textContent = isSuccess ? 'Transaction Successful' : (isFailed ? 'Transaction Failed' : 'Transaction Pending');
      title.appendChild(tIcon); title.appendChild(tText);
      const badge = document.createElement('div');
      let lbl = 'PENDING', cls = 'status-pending';
      if (model.status === 'success') { lbl = 'SUCCESS'; cls = 'status-success'; }
      else if (model.status === 'failed') { lbl = 'FAILED'; cls = 'status-failed'; }
      badge.className = 'status-badge ' + cls;
      badge.setAttribute('aria-label', model.status);
      badge.textContent = `${lbl} â€¢ ${model.backendStatus || 'ON-CHAIN'}`;
      header.appendChild(title); header.appendChild(badge);

      const body = document.createElement('div'); body.className = 'receipt-body';
      const grid = document.createElement('div'); grid.className = 'receipt-grid';
      const amt = model.amountDisplay ? model.amountDisplay : formatTokenAmount(model.amountWei || '0', model.decimals || 6, model.symbol || 'CNGN');
      const fields = [
        { k: 'Timestamp', v: new Date(model.timestamp || Date.now()).toLocaleString() },
        { k: 'Network', v: `${model.networkName || 'Assetchain'} (${model.chainId || '0xA5B4'})` },
        { k: 'Service', v: model.service || 'â€”' },
        { k: 'Value', v: model.purchaseValue || amt },
        { k: 'Service Provider', v: model.providerDisplay || 'â€”' },
        { k: 'Recipient', v: model.recipientPhone || 'N/A' },
        { k: 'Description', v: model.description || 'â€”' },
        { k: 'Amount', v: amt },
      ];
      if (model.hash) {
        const kv = document.createElement('div'); kv.className = 'kv';
        const k = document.createElement('div'); k.className = 'k'; k.textContent = 'Transaction Hash';
        const v = document.createElement('a'); v.className = 'v'; v.textContent = model.hash;
        const url = buildExplorerUrl('tx', model.chainIdHex || '0xA5B4', model.hash);
        if (url) { v.href = url; v.target = '_blank'; v.rel = 'noopener noreferrer'; }
        kv.appendChild(k); kv.appendChild(v); grid.appendChild(kv);
      }
      fields.forEach(({ k, v }) => {
        const kv = document.createElement('div'); kv.className = 'kv';
        const kk = document.createElement('div'); kk.className = 'k'; kk.textContent = k;
        const vv = document.createElement('div'); vv.className = 'v'; vv.textContent = v;
        if (k === 'Network Provider') vv.classList.add('kv-provider');
        kv.appendChild(kk); kv.appendChild(vv); grid.appendChild(kv);
      });

      if (model.message) {
        const kvm = document.createElement('div'); kvm.className = 'kv';
        const kk = document.createElement('div'); kk.className = 'k'; kk.textContent = 'Message';
        const vv = document.createElement('div'); vv.className = 'v'; vv.textContent = model.message;
        kvm.appendChild(kk); kvm.appendChild(vv); grid.appendChild(kvm);
      }
      body.appendChild(grid);

      const footer = document.createElement('div'); footer.className = 'receipt-footer';
      const btnView = document.createElement('button'); btnView.className = 'btn btn-primary'; btnView.textContent = 'View Receipt'; btnView.setAttribute('aria-label', 'Open full receipt');
      const btnExp = document.createElement('button'); btnExp.className = 'btn btn-secondary'; btnExp.textContent = 'Check Explorer'; btnExp.setAttribute('aria-label', 'Open transaction in explorer');
      btnView.onclick = () => {
        try {
          const params = new URLSearchParams({ status: model.status || 'pending', amount: String(model.tokenAmount || '0'), symbol: model.symbol || '', sender: model.from || '', target: model.to || '', txHash: model.hash || '', timestamp: String(model.timestamp || Date.now()), service: model.service || '', provider: model.providerDisplay || 'N/A', recipient: model.recipientPhone || 'N/A', fiatValue: model.amountDisplay || '', reference: model.reference || '', tokenAmount: model.tokenAmount || '', description: model.description || '' });
          const url = 'receipt.html?' + params.toString();
          window.open(url, '_blank', 'noopener');
        } catch (_) { }
      };
      btnExp.onclick = () => {
        // Ensure chainIdHex is valid or fallback to default
        const chainId = model.chainIdHex || window.ASSETCHAIN_ID_HEX || '0xA5B4';
        const url = buildExplorerUrl('tx', chainId, model.hash);
        if (url) {
          window.open(url, '_blank', 'noopener');
        } else {
          console.warn('Could not build explorer URL', { chainId, hash: model.hash });
        }
      };
      footer.appendChild(btnView); footer.appendChild(btnExp);

      card.appendChild(header); card.appendChild(body); card.appendChild(footer);
      wrap.prepend(card);
      return card;
    }

    // Create a receipt card element After Sending Transaction (shared between inline and modal)
    function createReceiptCard(model) {
      const card = document.createElement('div');
      card.className = 'receipt-card';
      const header = document.createElement('div'); header.className = 'receipt-header';
      const title = document.createElement('div'); title.className = 'receipt-title';
      const isSuccess = String(model.status).toLowerCase() === 'success';
      const isFailed = String(model.status).toLowerCase() === 'failed';
      const tIcon = document.createElement('span'); tIcon.innerHTML = `<i class="fas ${isSuccess ? 'fa-check-circle' : (isFailed ? 'fa-exclamation-circle' : 'fa-hourglass-half')}"></i>`;
      const tText = document.createElement('span'); tText.textContent = isSuccess ? 'Transaction Successful' : (isFailed ? 'Transaction Failed' : 'Transaction Pending');
      title.appendChild(tIcon); title.appendChild(tText);
      const badge = document.createElement('div');
      let lbl = 'PENDING', cls = 'status-pending';
      if (isSuccess) { lbl = 'SUCCESS'; cls = 'status-success'; }
      else if (isFailed) { lbl = 'FAILED'; cls = 'status-failed'; }
      badge.className = 'status-badge ' + cls;
      badge.setAttribute('aria-label', model.status);
      badge.textContent = `${lbl} â€¢ ${model.backendStatus || 'ON-CHAIN'}`;
      header.appendChild(title); header.appendChild(badge);

      const body = document.createElement('div'); body.className = 'receipt-body';
      const grid = document.createElement('div'); grid.className = 'receipt-grid';
      const amt = model.amountDisplay ? model.amountDisplay : formatTokenAmount(model.amountWei || '0', model.decimals || 6, model.symbol || 'CNGN');
      const fields = [
        { k: 'Timestamp', v: new Date(model.timestamp || Date.now()).toLocaleString() },
        { k: 'Network', v: `${model.networkName || 'Assetchain'} (${model.chainId || '0xA5B4'})` },
        { k: 'Service', v: model.service || 'â€”' },
        { k: 'Value', v: model.purchaseValue || amt },
        { k: 'Service Provider', v: model.providerDisplay || 'â€”' },
        { k: 'Recipient', v: model.recipientPhone || 'N/A' },
        { k: 'Description', v: model.description || 'â€”' },
        { k: 'Amount', v: amt },
      ];
      if (model.hash) {
        const kv = document.createElement('div'); kv.className = 'kv';
        const k = document.createElement('div'); k.className = 'k'; k.textContent = 'Transaction Hash';
        const v = document.createElement('a'); v.className = 'v'; v.textContent = model.hash;
        const url = buildExplorerUrl('tx', model.chainIdHex || '0xA5B4', model.hash);
        if (url) { v.href = url; v.target = '_blank'; v.rel = 'noopener noreferrer'; }
        kv.appendChild(k); kv.appendChild(v); grid.appendChild(kv);
      }
      fields.forEach(({ k, v }) => {
        const kv = document.createElement('div'); kv.className = 'kv';
        const kk = document.createElement('div'); kk.className = 'k'; kk.textContent = k;
        const vv = document.createElement('div'); vv.className = 'v'; vv.textContent = v;
        if (k === 'Network Provider') vv.classList.add('kv-provider');
        kv.appendChild(kk); kv.appendChild(vv); grid.appendChild(kv);
      });

      if (model.message) {
        const kvm = document.createElement('div'); kvm.className = 'kv';
        const kk = document.createElement('div'); kk.className = 'k'; kk.textContent = 'Message';
        const vv = document.createElement('div'); vv.className = 'v'; vv.textContent = model.message;
        kvm.appendChild(kk); kvm.appendChild(vv); grid.appendChild(kvm);
      }
      body.appendChild(grid);

      const footer = document.createElement('div'); footer.className = 'receipt-footer';
      const btnView = document.createElement('button'); btnView.className = 'btn btn-primary'; btnView.textContent = 'View Receipt'; btnView.setAttribute('aria-label', 'Open full receipt');
      const btnExp = document.createElement('button'); btnExp.className = 'btn btn-secondary'; btnExp.textContent = 'Check Explorer'; btnExp.setAttribute('aria-label', 'Open transaction in explorer');
      btnView.onclick = () => {
        try {
          // Ensure we have valid values for the receipt, falling back to calculated values if needed
          const amtDisplay = model.amountDisplay || formatTokenAmount(model.amountWei || '0', model.decimals || 6, model.symbol || 'CNGN');
          const tAmount = model.tokenAmount || amtDisplay;

          // Strip symbol from amount/tokenAmount for URL params as receipt.html adds it separately
          const numericAmount = String(tAmount).split(' ')[0];

          const params = new URLSearchParams({
            status: model.status || 'pending',
            amount: numericAmount,
            symbol: model.symbol || 'CNGN',
            sender: model.from || '',
            target: model.to || '',
            txHash: model.hash || '',
            timestamp: String(model.timestamp || Date.now()),
            service: model.service || '',
            provider: model.providerDisplay || 'N/A',
            recipient: model.recipientPhone || 'N/A',
            fiatValue: amtDisplay,
            reference: model.reference || model.ref || 'N/A',
            tokenAmount: numericAmount,
            description: model.description || ''
          });
          const url = 'receipt.html?' + params.toString();
          window.open(url, '_blank', 'noopener');
        } catch (e) { console.error('Error opening receipt:', e); }
      };
      btnExp.onclick = () => {
        // Ensure chainIdHex is valid or fallback to default
        const chainId = model.chainIdHex || window.ASSETCHAIN_ID_HEX || '0xA5B4';
        const url = buildExplorerUrl('tx', chainId, model.hash);
        if (url) {
          window.open(url, '_blank', 'noopener');
        } else {
          console.warn('Could not build explorer URL', { chainId, hash: model.hash });
        }
      };
      footer.appendChild(btnView); footer.appendChild(btnExp);

      card.appendChild(header); card.appendChild(body); card.appendChild(footer);
      return card;
    }

    function openReceiptModal(model) {
      const modal = document.getElementById('tx-modal');
      const body = document.getElementById('tx-modal-body');
      const title = document.getElementById('tx-modal-title');
      if (!modal || !body || !title) return null;
      title.textContent = 'Transaction Summary';
      body.innerHTML = '';
      const card = createReceiptCard(model);
      body.appendChild(card);
      const closeBtn = document.getElementById('tx-modal-close');
      const backdrop = modal.querySelector('.tx-backdrop');
      const close = () => { modal.style.display = 'none'; modal.setAttribute('aria-hidden', 'true'); document.removeEventListener('keydown', onKey); };
      const onKey = (ev) => { if (ev.key === 'Escape') close(); };
      document.addEventListener('keydown', onKey);
      if (closeBtn) closeBtn.onclick = close;
      if (backdrop) backdrop.onclick = close;
      modal.style.display = 'inline-flex';
      modal.setAttribute('aria-hidden', 'false');
      return card;
    }

    function printReceipt(node) {
      try { window.focus(); window.print(); return true; } catch (_) { return false; }
    }

    async function exportReceiptAsImage(node, type = 'png') {
      const rect = node.getBoundingClientRect();
      const w = Math.ceil(rect.width);
      const h = Math.ceil(rect.height);
      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('width', w); svg.setAttribute('height', h);
      svg.setAttribute('viewBox', `0 0 ${w} ${h}`);
      const fo = document.createElementNS('http://www.w3.org/2000/svg', 'foreignObject');
      fo.setAttribute('x', '0'); fo.setAttribute('y', '0'); fo.setAttribute('width', w); fo.setAttribute('height', h);
      const cloned = node.cloneNode(true);
      cloned.style.margin = '0'; cloned.style.width = `${w}px`;
      const div = document.createElement('div'); div.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml'); div.appendChild(cloned);
      fo.appendChild(div); svg.appendChild(fo);
      const data = new XMLSerializer().serializeToString(svg);
      const img = new Image();
      const url = 'data:image/svg+xml;charset=utf-8,' + encodeURIComponent(data);
      await new Promise((resolve, reject) => { img.onload = resolve; img.onerror = reject; img.src = url; });
      const canvas = document.createElement('canvas'); canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0);
      const mime = type === 'jpeg' ? 'image/jpeg' : 'image/png';
      const dl = document.createElement('a'); dl.href = canvas.toDataURL(mime, 0.92); dl.download = `transaction_${Date.now()}.${type === 'jpeg' ? 'jpg' : 'png'}`; dl.click();
    }

    // Set up calculation buttons
    $('#airtime-calc').addEventListener('click', async () => {
      const btn = $('#airtime-calc');
      const btnBuy = $('#airtime-send');
      const originalHtml = btn.innerHTML;

      try {
        // Loading State
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Calculating...';
        $('#airtime-status').innerHTML = '';

        // Validation
        const network = $('#airtime-network').value;
        const phone = $('#airtime-phone').value;
        const ngn = parseFloat($('#airtime-amount').value || '0');

        if (!network) throw new Error('Please select a network provider');
        if (!phone) throw new Error('Please enter a phone number');
        if (!ngn) throw new Error('Please enter a valid amount');

        const wei = await calcWeiFromNaira(ngn);
        const nano = $('#airtime-nano'); if (nano) nano.value = wei;

        if (!wei) {
          throw new Error('Failed to calculate token amount (swap or token unavailable)');
        } else {
          const sel = document.getElementById('airtime-token');
          const dec = Number(sel?.selectedOptions[0]?.getAttribute('data-decimals') || 6);
          const name = sel?.selectedOptions[0]?.text || '';
          const disp = $('#airtime-display'); if (disp) disp.value = formatTokenAmount(wei, dec, name);

          // Success Transition
          btn.style.display = 'none';
          btn.innerHTML = originalHtml; // Restore text for when it reappears
          btn.disabled = false;

          btnBuy.style.display = 'inline-block';
          btnBuy.disabled = false;

          // 10s Timer
          if (btnBuy.dataset.timer) clearTimeout(Number(btnBuy.dataset.timer));
          btnBuy.dataset.timer = setTimeout(() => {
            btnBuy.style.display = 'none';
            btnBuy.disabled = true;
            btn.style.display = 'inline-block';
          }, 10000);
        }
      } catch (e) {
        showStatus($('#airtime-status'), e.message, false);
        const disp = $('#airtime-display'); if (disp) disp.value = '';
        const nano = $('#airtime-nano'); if (nano) nano.value = '';
        btn.disabled = false;
        btn.innerHTML = originalHtml;
      }
    });

    $('#data-calc').addEventListener('click', async () => {
      const btn = $('#data-calc');
      const btnBuy = $('#data-send');
      const originalHtml = btn.innerHTML;

      try {
        // Pre-checks
        if (typeof ethers === 'undefined') {
          throw new Error('Ethers.js library not loaded');
        }

        if (!window.availableTokens || window.availableTokens.length === 0) {
          throw new Error('Tokens not loaded yet');
        }

        // Loading State
        btn.disabled = true;
        btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Calculating...';
        $('#data-status').innerHTML = '';

        const network = $('#data-network').value;
        const plan = $('#data-plan').value;
        const phone = $('#data-phone').value;

        if (!network) throw new Error('Please select a network provider');
        if (!plan) throw new Error('Please select a data plan');
        if (!phone) throw new Error('Please enter a phone number');

        const res = await fetch(`${apiBase}/access.php?action=checkDataPlanPrice&network=${encodeURIComponent(network)}&plan=${encodeURIComponent(plan)}`);
        const data = await res.json();
        const ngn = Number(data.amount || data.price || data.naira || 0);

        if (!ngn) throw new Error('Failed to fetch plan price');

        const wei = ngn ? await calcWeiFromNairaBySelector('data-token', ngn) : '';

        // SAFE assignment to data-nano
        const nanoEl = $('#data-nano');
        if (nanoEl) {
          nanoEl.value = wei;
        }

        if (!wei) {
          throw new Error('Failed to calculate token amount (swap or token unavailable)');
        } else {
          const sel = document.getElementById('data-token');
          const dec = Number(sel?.selectedOptions[0]?.getAttribute('data-decimals') || 6);
          const name = sel?.selectedOptions[0]?.text || '';
          const formatted = formatTokenAmount(wei, dec, name);
          // showStatus($('#data-status'), `Amount: ${formatted}`, true);

          // SAFE assignment to data-display
          const displayEl = $('#data-display');
          if (displayEl) {
            displayEl.value = formatted;
          }

          // Success Transition
          btn.style.display = 'none';
          btn.innerHTML = originalHtml;
          btn.disabled = false;

          btnBuy.style.display = 'inline-block';
          btnBuy.disabled = false;

          // 10s Timer
          if (btnBuy.dataset.timer) clearTimeout(Number(btnBuy.dataset.timer));
          btnBuy.dataset.timer = setTimeout(() => {
            btnBuy.style.display = 'none';
            btnBuy.disabled = true;
            btn.style.display = 'inline-block';
          }, 10000);
        }
      } catch (e) {
        showStatus($('#data-status'), e.message, false);

        // SAFE clearing of values
        const displayEl = $('#data-display');
        if (displayEl) displayEl.value = '';

        const nanoEl = $('#data-nano');
        if (nanoEl) nanoEl.value = '';

        btn.disabled = false;
        btn.innerHTML = originalHtml;
      }
    });
    function prepareTransactionDataDex(data) {
      const txHash = data.hash || data.in_msg?.hash;
      const value = data.out_msgs?.[0]?.value || data.in_msg?.value || 0;
      const userAddress = data.account?.address || '';
      return {
        tx_hash: txHash,
        user_address: userAddress,
        amount_wei: String(value),
        token_contract: '0x7923C0f6FA3d1BA6EAFCAedAaD93e737Fd22FC4F'
      };
    }

    // --- Assetchain + Ethers.js helpers (no Onboard) ---
    const ASSETCHAIN_ID_HEX = '0xA5B4'; // 42420
    const CNGN_CONTRACT = '0x7923C0f6FA3d1BA6EAFCAedAaD93e737Fd22FC4F';

    function getEthers() {
      if (!window.ethers) {
        if (window.toastr) toastr.error('Ethers.js failed to load. Check your connection.');
        throw new Error('ethers not loaded');
      }
      const walletProvider = window.currentProvider || window.ethereum || null;
      if (!walletProvider || typeof walletProvider.request !== 'function') {
        if (window.toastr) toastr.error('No wallet connected. Please connect a wallet.');
        throw new Error('no provider');
      }
      const web3Provider = new ethers.providers.Web3Provider(walletProvider, 'any');
      const signer = web3Provider.getSigner();
      return { provider: web3Provider, signer };
    }

    function getErc20Contract(address, signer) {
      const abi = [
        'function transfer(address to, uint256 amount) returns (bool)',
        'function balanceOf(address owner) view returns (uint256)'
      ];
      return new ethers.Contract(address, abi, signer);
    }

    function toWeiFromInput(inputValue) {
      const v = (inputValue || '').trim();
      if (!v) return null;
      if (!/^\d+$/.test(v)) {
        toastr.error('Amount must be a positive integer in wei.');
        return null;
      }
      return ethers.BigNumber.from(v);
    }

    async function sendTokenTransfer(signer, tokenAddress, toAddress, amountWeiBN) {
      const erc20 = getErc20Contract(tokenAddress, signer);
      const tx = await erc20.transfer(toAddress, amountWeiBN);
      const receipt = await tx.wait();
      return receipt;
    }

    // Fetch DEX authorization token
    async function getDexToken() {
      try {
        const res = await fetch(`${apiBase}/access.php?action=getDexToken`);
        const data = await res.json();
        return data.status === 'success' ? data.token : null;
      } catch (e) {
        console.error('Failed to fetch DEX token:', e);
        return null;
      }
    }

    // Verify and fulfill order
    async function verifyAndFulfil(service, payload) {
      const endpoint = service === 'airtime' ? `${apiBase}/airtime/` : `${apiBase}/data/`;
      const token = await getDexToken();

      const headers = { 'Content-Type': 'application/json' };
      if (token) {
        headers['Authorization'] = `Token ${token}`;
      }

      const res = await fetch(endpoint, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(payload)
      });
      return res.json();
    }

    function showGlobalLoader() {
      const loader = document.getElementById('global-loader');
      if (!loader) return;

      loader.classList.add('visible');
      loader.setAttribute('aria-hidden', 'false');
      loader.setAttribute('aria-busy', 'true');

      // Disable all interactive elements
      document.body.style.overflow = 'hidden';
    }

    function hideGlobalLoader() {
      const loader = document.getElementById('global-loader');
      if (!loader) return;

      loader.classList.remove('visible');
      loader.setAttribute('aria-hidden', 'true');
      loader.setAttribute('aria-busy', 'false');

      // Restore interactivity
      document.body.style.overflow = '';
    }

    // Button State Helper
    function setButtonState(btnId, state, text) {
      const btn = document.getElementById(btnId);
      if (!btn) return;

      if (state === 'loading') {
        btn.disabled = true;
        btn.classList.add('loading');
        btn.setAttribute('aria-busy', 'true');
        if (!btn.dataset.originalHtml) btn.dataset.originalHtml = btn.innerHTML;
        btn.innerHTML = `<span class="spinner" aria-hidden="true"></span> <span class="btn-text">${text || 'Processing...'}</span>`;
      } else if (state === 'disabled') {
        btn.disabled = true;
        btn.classList.remove('loading');
        btn.setAttribute('aria-busy', 'false');
      } else { // idle
        btn.disabled = false;
        btn.classList.remove('loading');
        btn.setAttribute('aria-busy', 'false');
        if (btn.dataset.originalHtml) btn.innerHTML = btn.dataset.originalHtml;
      }
    }

    // Persistent Transaction Storage
    const PENDING_TX_KEY = 'dex_pending_tx';
    function savePendingTx(data) {
      try { localStorage.setItem(PENDING_TX_KEY, JSON.stringify(data)); } catch (_) { }
    }
    function getPendingTx() {
      try { return JSON.parse(localStorage.getItem(PENDING_TX_KEY)); } catch (_) { return null; }
    }
    function clearPendingTx() {
      try { localStorage.removeItem(PENDING_TX_KEY); } catch (_) { }
    }

    // Handle sending CNGN via selected wallet provider on Assetchain
    async function handleSend(service) {
      const btnId = service === 'airtime' ? 'airtime-send' : 'data-send';
      const statusEl = service === 'airtime' ? $('#airtime-status') : $('#data-status');

      // Validation Check
      if (service === 'airtime') {
        if (!$('#airtime-network').value) { showStatus(statusEl, 'Please select a network provider', false); return; }
        if (!$('#airtime-phone').value) { showStatus(statusEl, 'Please enter a phone number', false); return; }
        if (!parseFloat($('#airtime-amount').value)) { showStatus(statusEl, 'Please enter a valid amount', false); return; }
      } else {
        if (!$('#data-network').value) { showStatus(statusEl, 'Please select a network provider', false); return; }
        if (!$('#data-plan').value) { showStatus(statusEl, 'Please select a data plan', false); return; }
        if (!$('#data-phone').value) { showStatus(statusEl, 'Please enter a phone number', false); return; }
      }

      // 1. Immediate disable and visual state
      setButtonState(btnId, 'loading', 'Preparing...');
      showGlobalLoader();

      try {
        const authOk = await requireAuthSequence();
        if (!authOk) {
          showStatus(statusEl, 'Authentication required: connect wallet, switch to Assetchain, then sign in.', false);
          hideGlobalLoader();
          setButtonState(btnId, 'idle');
          return;
        }

        const selected = localStorage.getItem('dex_last_wallet') || window.currentWalletName || 'MetaMask';
        const ethProvider = window.currentProvider || resolveProviderBySelection(selected);
        if (!ethProvider || typeof ethProvider.request !== 'function') {
          showStatus(statusEl, `${selected} wallet not installed or unavailable.`, false);
          hideGlobalLoader();
          setButtonState(btnId, 'idle');
          return;
        }

        setButtonState(btnId, 'loading', 'Connecting...');
        try {
          await ethProvider.request({ method: 'eth_requestAccounts' });
        } catch (e) {
          showStatus(statusEl, e?.message || 'Wallet connection cancelled or failed.', false);
          hideGlobalLoader();
          setButtonState(btnId, 'idle');
          return;
        }

        const selectedChainKey = getSelectedChain();
        const chainConfig = CHAINS[selectedChainKey];
        if (!chainConfig) {
          showStatus(statusEl, 'Invalid chain selection.', false);
          hideGlobalLoader();
          setButtonState(btnId, 'idle');
          return;
        }

        // Ensure Correct Network
        setButtonState(btnId, 'loading', `Switching to ${chainConfig.chainName}...`);
        try {
          await ethProvider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: chainConfig.chainId }] });
        } catch (switchErr) {
          const code = switchErr?.code;
          if (code === 4902 || code === -4902 || code === -32603) {
            try {
              await ethProvider.request({
                method: 'wallet_addEthereumChain',
                params: [{
                  chainId: chainConfig.chainId,
                  chainName: chainConfig.chainName,
                  nativeCurrency: chainConfig.nativeCurrency,
                  rpcUrls: chainConfig.rpcUrls,
                  blockExplorerUrls: chainConfig.blockExplorerUrls
                }]
              });
            } catch (_) { }
          } else {
            showStatus(statusEl, `Please switch to ${chainConfig.chainName}.`, false);
            hideGlobalLoader();
            setButtonState(btnId, 'idle');
            return;
          }
        }

        // Normalize provider for Ethers usage
        window.ethereum = ethProvider;
        const { signer } = getEthers();
        const userAddress = await signer.getAddress();

        const target = service === 'airtime' ? $('#airtime-target').value.trim() : $('#data-target').value.trim();
        const nano = service === 'airtime' ? $('#airtime-nano').value.trim() : $('#data-nano').value.trim();
        const tokenSel = service === 'airtime' ? document.getElementById('airtime-token') : document.getElementById('data-token');
        const tokenContract = tokenSel?.value || CNGN_CONTRACT;
        const tokenDecimals = Number(tokenSel?.selectedOptions[0]?.getAttribute('data-decimals') || 6);

        if (!/^0x[a-fA-F0-9]{40}$/.test(target)) {
          showStatus(statusEl, 'Target address must be a valid EVM address.', false);
          hideGlobalLoader();
          setButtonState(btnId, 'idle');
          return;
        }

        const amountWeiBN = toWeiFromInput(nano);
        if (!amountWeiBN) {
          hideGlobalLoader();
          setButtonState(btnId, 'idle');
          return;
        }

        // Handle Native vs ERC20 Balance Check and Transfer
        const isNative = !tokenContract || !tokenContract.startsWith('0x') || tokenContract.toLowerCase() === 'native' || tokenContract === '0x0000000000000000000000000000000000000000';

        if (isNative) {
          const balance = await signer.getBalance();
          if (balance.lt(amountWeiBN)) {
            showStatus(statusEl, 'Insufficient native balance for this transfer.', false);
            hideGlobalLoader();
            setButtonState(btnId, 'idle');
            return;
          }
        } else {
          const erc20 = getErc20Contract(tokenContract, signer);
          const balance = await erc20.balanceOf(userAddress);
          if (balance.lt(amountWeiBN)) {
            showStatus(statusEl, 'Insufficient token balance for this transfer.', false);
            hideGlobalLoader();
            setButtonState(btnId, 'idle');
            return;
          }
        }

        showStatus(statusEl, 'Sending transaction...', true);
        setButtonState(btnId, 'loading', 'Confirm in Wallet...');

        let receipt;
        if (isNative) {
          const tx = await signer.sendTransaction({
            to: target,
            value: amountWeiBN
          });
          receipt = await tx.wait();
        } else {
          receipt = await sendTokenTransfer(signer, tokenContract, target, amountWeiBN);
        }

        showStatus(statusEl, 'Transaction sent. Verifying on-chain...', true);
        setButtonState(btnId, 'loading', 'Verifying...');

        const network = await signer.provider.getNetwork();
        const chainIdHex = '0x' + Number(network.chainId || 0).toString(16).toUpperCase();
        const model = {
          status: 'pending',
          backendStatus: 'PENDING',
          timestamp: Date.now(),
          hash: receipt.transactionHash,
          from: userAddress,
          to: target,
          amountWei: amountWeiBN.toString(),
          decimals: tokenDecimals,
          symbol: (tokenSel?.selectedOptions[0]?.text || '').toUpperCase(),
          networkName: chainConfig.chainName,
          chainId: chainIdHex,
          chainIdHex,
          providerDisplay: await resolveProviderDisplay(service),
          recipientPhone: (service === 'airtime' ? $('#airtime-phone').value : $('#data-phone').value) || 'N/A',
          service: service === 'airtime' ? 'Airtime Purchase' : 'Data Purchase',
          purchaseValue: service === 'airtime' ? `${$('#airtime-amount').value || ''}N` : `${($('#data-plan').selectedOptions[0]?.text || $('#data-plan').value || '').toString()} Data`
        };
        const modalCard = openReceiptModal(model);

        const base = {
          target_address: target,
          tx_hash: receipt.transactionHash,
          user_address: userAddress,
          amount_wei: amountWeiBN.toString(),
          token_contract: tokenContract
        };

        let payload;
        if (service === 'airtime') {
          payload = {
            ...base,
            network: $('#airtime-network').value,
            phone: $('#airtime-phone').value,
            amount: $('#airtime-amount').value,
            ref: $('#airtime-ref').value,
            ported_number: $('#airtime-ported').checked
          };
        } else {
          payload = {
            ...base,
            network: $('#data-network').value,
            data_plan: $('#data-plan').value,
            phone: $('#data-phone').value,
            ref: $('#data-ref').value,
            ported_number: $('#data-ported').checked
          };
        }

        // Save pending state
        savePendingTx({
          hash: receipt.transactionHash,
          service,
          model,
          payload,
          timestamp: Date.now()
        });

        // Timeout protection (60s)
        const timeoutMs = 60000;
        const timeoutPromise = new Promise((_, reject) =>
          setTimeout(() => reject(new Error('Transaction verification timed out. Please check history.')), timeoutMs)
        );

        const out = await Promise.race([
          verifyAndFulfil(service, payload),
          timeoutPromise
        ]);

        const isSuccess = (out.status === 'success') || (out.status === true) || (out.success === true);
        const msg = out.msg || out.message || (isSuccess ? 'Transaction successful!' : 'Transaction failed');

        showStatus(statusEl, msg, isSuccess);

        // Update model for final receipt state and re-render modal
        // This ensures accurate status representation, correct badge colors, and updated receipt links
        const finalModel = {
          ...model,
          status: isSuccess ? 'success' : 'failed',
          backendStatus: 'HISTORY',
          message: isSuccess ? null : msg, // Only show error message on failure
          amountDisplay: service === 'airtime' ? $('#airtime-display').value : $('#data-display').value,
          ref: service === 'airtime' ? $('#airtime-ref').value : $('#data-ref').value,
          tokenAmount: formatTokenAmount(model.amountWei || '0', model.decimals || 6, model.symbol || 'CNGN')
        };

        hideGlobalLoader();
        setButtonState(btnId, 'idle');
        openReceiptModal(finalModel);

        // Clear pending on final result
        clearPendingTx();

        if (isSuccess) {
          notify('success', 'Transaction successful!');
        } else {
          notify('error', 'Transaction failed.');
        }

        // Always reset ref
        if (service === 'airtime') {
          $('#airtime-ref').value = randRef();
        } else {
          $('#data-ref').value = randRef();
        }
      } catch (e) {
        hideGlobalLoader();
        setButtonState(btnId, 'idle');
        const statusEl = service === 'airtime' ? $('#airtime-status') : $('#data-status');
        showStatus(statusEl, 'Error: ' + (e && e.message ? e.message : 'Unknown error'), false);
        try {
          const provider = window.currentProvider || window.ethereum;
          const chainIdHex = await getChainId(provider) || ASSETCHAIN_ID_HEX;
          const NetworkName = await getNetworkName(provider) || 'Unknown';
          const providerDisplay = await resolveProviderDisplay(service);
          const descText = String('Error occurred');
          const extractedPhone = (service === 'airtime' ? $('#airtime-phone').value : $('#data-phone').value) || 'N/A';
          const netOk = /Assetchain/i.test(String(NetworkName));

          // If we have a pending tx, we might want to use its info
          const pending = getPendingTx();

          renderReceipt({
            status: 'failed',
            backendStatus: 'CLIENT',
            timestamp: Date.now(),
            hash: pending ? pending.hash : null,
            from: window.currentAddress || '',
            to: (service === 'airtime' ? $('#airtime-target').value : $('#data-target').value) || '',
            amountWei: (service === 'airtime' ? $('#airtime-nano').value : $('#data-nano').value) || '0',
            decimals: 6,
            symbol: 'CNGN',
            networkName: netOk ? 'Assetchain Mainnet' : 'Unknown',
            chainId: chainIdHex,
            chainIdHex,
            providerDisplay,
            recipientPhone: extractedPhone,
            service: service === 'airtime' ? 'Airtime Purchase' : 'Data Purchase',
            message: e && e.message ? e.message : 'Unknown error'
          });
        } catch (_) { }
        showAlert('Error', e && e.message ? e.message : 'Unknown error occurred.', { okText: 'OK' });

        // Always reset ref on error too
        if (service === 'airtime') {
          $('#airtime-ref').value = randRef();
        } else {
          $('#data-ref').value = randRef();
        }
      }
    }

    // Show status message
    function showStatus(element, message, isSuccess) {
      const displayMsg = isSuccess ? message : cleanErrorMessage(message);
      element.innerHTML = `
        <div class="status-message ${isSuccess ? 'status-success' : 'status-error'}">
          <i class="fas ${isSuccess ? 'fa-check-circle' : 'fa-exclamation-circle'}"></i>
          ${displayMsg}
        </div>
      `;
    }

    // Set up send buttons
    $('#airtime-send').addEventListener('click', () => handleSend('airtime'));
    $('#data-send').addEventListener('click', () => handleSend('data'));

    // Set up reset buttons
    $('#airtime-reset').addEventListener('click', () => {
      $('#airtime-phone').value = '';
      $('#airtime-amount').value = '';
      $('#airtime-nano').value = '';
      $('#airtime-ref').value = randRef();
      $('#airtime-status').innerHTML = '';
    });

    $('#data-reset').addEventListener('click', () => {
      $('#data-phone').value = '';
      $('#data-nano').value = '';
      $('#data-ref').value = randRef();
      $('#data-status').innerHTML = '';
    });

    // Initialize input listeners for button behavior logic
    function initInputListeners() {
      const sections = ['airtime', 'data'];
      sections.forEach(section => {
        // Select all relevant inputs and selects
        const inputs = $$(`#${section}-tab input, #${section}-tab select`);
        const btnCalc = $(`#${section}-calc`);
        const btnBuy = $(`#${section}-send`);

        const resetState = () => {
          // Hide Buy, Show Calc
          if (btnBuy) {
            btnBuy.style.display = 'none';
            btnBuy.disabled = true;
            // Clear timer
            if (btnBuy.dataset.timer) {
              clearTimeout(Number(btnBuy.dataset.timer));
              btnBuy.dataset.timer = '';
            }
          }

          if (btnCalc) {
            btnCalc.style.display = 'inline-block';
            btnCalc.disabled = false;
            // Reset text if it was stuck
            if (btnCalc.innerHTML.includes('Calculating')) {
              btnCalc.innerHTML = '<i class="fas fa-calculator"></i> Calculate Amount';
            }
          }

          // Reset calculations display
          const nano = $(`#${section}-nano`);
          const display = $(`#${section}-display`);
          const status = $(`#${section}-status`);

          if (nano) nano.value = '';
          if (display) display.value = '';
          if (status) status.innerHTML = '';
        };

        inputs.forEach(input => {
          input.addEventListener('input', resetState);
          input.addEventListener('change', resetState);
        });

        // Also clear timer on Buy click so it doesn't revert while buying
        if (btnBuy) {
          btnBuy.addEventListener('click', () => {
            if (btnBuy.dataset.timer) {
              clearTimeout(Number(btnBuy.dataset.timer));
              btnBuy.dataset.timer = '';
            }
          });
        }
      });
    }
    initInputListeners();

    // Check for pending transactions on load
    async function checkPendingTxs() {
      const pending = getPendingTx();
      if (!pending || !pending.hash) return;

      // If it's too old (> 10 mins), clear it
      if (Date.now() - (pending.timestamp || 0) > 600000) {
        clearPendingTx();
        return;
      }

      if (pending.service) {
        const btnId = pending.service === 'airtime' ? 'airtime-send' : 'data-send';
        const statusEl = pending.service === 'airtime' ? $('#airtime-status') : $('#data-status');

        setButtonState(btnId, 'loading', 'Resuming...');
        showGlobalLoader();
        showStatus(statusEl, 'Resuming pending transaction...', true);

        if (pending.model) openReceiptModal(pending.model);

        try {
          const out = await verifyAndFulfil(pending.service, pending.payload);
          const isSuccess = (out.status === 'success') || (out.status === true) || (out.success === true);
          const msg = out.msg || out.message || (isSuccess ? 'Transaction successful!' : 'Transaction failed');

          showStatus(statusEl, msg, isSuccess);

          const finalModel = {
            ...pending.model,
            status: isSuccess ? 'success' : 'failed',
            backendStatus: 'HISTORY',
            message: isSuccess ? null : msg,
            amountDisplay: pending.model.amountDisplay,
            ref: pending.model.ref,
            tokenAmount: pending.model.tokenAmount
          };

          hideGlobalLoader();
          setButtonState(btnId, 'idle');
          openReceiptModal(finalModel);
          clearPendingTx();

          if (isSuccess) {
            notify('success', 'Transaction restored and verified!');
          } else {
            notify('error', 'Transaction verification failed.');
          }

        } catch (e) {
          hideGlobalLoader();
          setButtonState(btnId, 'idle');
          showStatus(statusEl, 'Error resuming transaction: ' + e.message, false);
        }
      }
    }
    checkPendingTxs();

    // Inline unit tests (run with ?test=1)
    (function runInlineTests() {
      try {
        const params = new URLSearchParams(window.location.search);
        if (!params.get('test')) return;
        const tests = [];
        const assert = (name, cond) => { tests.push({ name, pass: !!cond }); };
        assert('isHexTx valid', isHexTx('0x' + 'a'.repeat(64)));
        assert('isHexTx invalid', !isHexTx('0x123'));
        assert('isHexAddress valid', isHexAddress('0x' + 'b'.repeat(40)));
        assert('buildExplorerUrl tx', !!buildExplorerUrl('tx', '0xA5B4', '0x' + 'a'.repeat(64)));
        assert('formatTokenAmount basic', formatTokenAmount('1000000', 6, 'CNGN').includes('1'));
        const dummyReceipt = { gasUsed: ethers.BigNumber.from('21000'), effectiveGasPrice: ethers.BigNumber.from('1000000000') };
        assert('computeGasFee', computeGasFee(dummyReceipt).includes('ASET'));

        // Test Button State
        const btn = document.createElement('button'); btn.id = 'test-btn'; document.body.appendChild(btn);
        setButtonState('test-btn', 'loading', 'Wait');
        assert('Button loading state', btn.disabled && btn.classList.contains('loading') && btn.innerHTML.includes('Wait'));
        setButtonState('test-btn', 'idle');
        assert('Button idle state', !btn.disabled && !btn.classList.contains('loading'));
        btn.remove();

        // Test renderReceipt status logic
        try {
          const testModel = { status: 'success', backendStatus: 'HISTORY', timestamp: Date.now() };
          const card = renderReceipt(testModel);
          const badge = card.querySelector('.status-badge');
          assert('Badge has success class', badge.classList.contains('status-success'));
          assert('Badge has correct text', badge.textContent.includes('SUCCESS â€¢ HISTORY'));

          const failModel = { status: 'failed', backendStatus: 'HISTORY', timestamp: Date.now() };
          const failCard = renderReceipt(failModel);
          const failBadge = failCard.querySelector('.status-badge');
          assert('Badge has failed class', failBadge.classList.contains('status-failed'));
          assert('Badge has correct text', failBadge.textContent.includes('FAILED â€¢ HISTORY'));
        } catch (e) { assert('renderReceipt test error: ' + e.message, false); }

        const node = document.createElement('div'); node.className = 'receipt-card'; node.textContent = 'test'; document.body.appendChild(node);
        exportReceiptAsImage(node).then(() => { assert('exportReceiptAsImage resolves', true); finish(); }).catch(() => { assert('exportReceiptAsImage resolves', false); finish(); });
        function finish() { console.group('Inline Tests'); tests.forEach(t => console[t.pass ? 'log' : 'error'](`${t.pass ? 'PASS' : 'FAIL'}: ${t.name}`)); console.groupEnd(); }
      } catch (e) { console.error('Tests failed to run', e); }
    })();

    // Theme Switcher Logic
    (function () {
      const toggleBtn = document.getElementById('theme-toggle');
      if (!toggleBtn) return;

      const icon = toggleBtn.querySelector('i');

      function setTheme(theme) {
        if (theme === 'light') {
          document.documentElement.setAttribute('data-theme', 'light');
          if (icon) {
            icon.className = 'fas fa-moon';
          }
        } else {
          document.documentElement.removeAttribute('data-theme');
          if (icon) {
            icon.className = 'fas fa-sun';
          }
        }
        localStorage.setItem('theme', theme);
      }

      // Init
      const savedTheme = localStorage.getItem('theme') || 'dark';
      setTheme(savedTheme);

      toggleBtn.addEventListener('click', () => {
        const current = document.documentElement.getAttribute('data-theme');
        setTheme(current === 'light' ? 'dark' : 'light');
      });
    })();
  </script>
  <!-- Loading Overlay -->
  <div id="global-loader" aria-hidden="true" role="dialog" aria-modal="true" aria-label="Transaction Processing">
    <div class="loader-spinner"></div>
    <div class="loader-text">Transaction Processing</div>
  </div>

  <!-- Onboard initialization removed; using custom wallet dropdown and EIP-1193 providers -->
</body>

</html>